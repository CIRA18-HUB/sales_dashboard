import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import os
import sys
import math
from openpyxl import Workbook
from openpyxl.styles import PatternFill, Font, Alignment, Border, Side
from openpyxl.utils.dataframe import dataframe_to_rows
from openpyxl.chart import BarChart, LineChart, PieChart, Reference
from openpyxl.chart.series import DataPoint
from openpyxl.utils import get_column_letter
import warnings
import matplotlib
import matplotlib.font_manager as fm
from matplotlib.ticker import MaxNLocator
from matplotlib.gridspec import GridSpec

warnings.filterwarnings('ignore')


class BatchLevelInventoryWarningSystem:
    """
批次级别库存积压预警系统
用于分析库存数据、销售数据和预测数据，提供库存积压预警
集成了责任归属分析，以识别造成库存积压的主要责任人或区域
"""

    def __init__(self, inventory_file, shipping_file, forecast_file, price_file=None):
        """
初始化预警系统

参数:
inventory_file (str): 库存数据文件路径
shipping_file (str): 出货数据文件路径
forecast_file (str): 预测数据文件路径
price_file (str): 产品单价数据文件路径
"""
        self.inventory_file = inventory_file
        self.shipping_file = shipping_file
        self.forecast_file = forecast_file
        self.price_file = price_file

        # 设置风险参数
        self.high_stock_days = 90  # 库存超过90天视为高风险
        self.medium_stock_days = 60  # 库存超过60天视为中风险
        self.low_stock_days = 30  # 库存超过30天视为低风险
        self.high_volatility_threshold = 1.0  # 出货波动系数超过1.0视为高波动
        self.medium_volatility_threshold = 0.8  # 出货波动系数超过0.8视为中等波动

        # 改进的预测偏差阈值 - 更合理的范围
        self.high_forecast_bias_threshold = 0.3  # 预测偏差超过30%视为高偏差（正负）
        self.medium_forecast_bias_threshold = 0.15  # 预测偏差超过15%视为中等偏差（正负）
        self.max_forecast_bias = 1.0  # 修改：预测偏差最大值，允许到100%（之前限制为60%）

        # 清库天数阈值
        self.high_clearance_days = 90  # 预计清库天数超过90天视为高风险
        self.medium_clearance_days = 60  # 预计清库天数超过60天视为中风险
        self.low_clearance_days = 30  # 预计清库天数超过30天视为低风险

        # 新增: 最小日均销量阈值，防止清库天数计算为无穷大
        self.min_daily_sales = 0.5  # 每天至少0.5件的销售量
        # 新增: 季节性指数下限，防止由于季节性太低导致调整后销量接近零
        self.min_seasonal_index = 0.3  # 季节性指数最低为0.3

        # 调整: 责任归属分析权重参数 - 更加平衡
        self.forecast_accuracy_weight = 0.25  # 预测准确性在责任判定中的权重
        self.recent_sales_weight = 0.30  # 最近销售在责任判定中的权重
        self.ordering_history_weight = 0.25  # 历史订货在责任判定中的权重
        self.market_performance_weight = 0.20  # 新增: 市场表现权重

        # 数据存储
        self.inventory_data = None
        self.batch_data = None
        self.shipping_data = None
        self.forecast_data = None
        self.price_data = None  # 新增：产品单价数据
        self.batch_analysis = None
        self.risk_assessment = None
        self.orders_data = None  # 新增：订单历史数据（模拟）
        self.sales_person_region_mapping = {}  # 新增: 销售人员-区域映射字典

        # 新增: 滚动预测准确率历史数据
        self.forecast_history = None

        # 默认区域和责任人
        self.default_regions = ['东', '南', '西', '北', '中']
        self.default_region = '东'  # 如果无法确定，使用默认区域
        self.default_person = '系统管理员'  # 如果无法确定，使用默认责任人

        # 报告输出路径
        # 获取桌面路径 - 增强错误处理和支持更多环境
        try:
            if os.name == 'nt':  # Windows
                desktop_path = os.path.join(os.path.expanduser('~'), 'Desktop')
                # 如果中文版Windows，尝试使用中文桌面路径
                if not os.path.exists(desktop_path):
                    desktop_path = os.path.join(os.path.expanduser('~'), '桌面')
            else:  # macOS/Linux
                desktop_path = os.path.join(os.path.expanduser('~'), 'Desktop')
                # 尝试使用中文桌面路径（适用于部分中文系统）
                if not os.path.exists(desktop_path):
                    desktop_path = os.path.join(os.path.expanduser('~'), '桌面')

            # 如果上述方法无法找到桌面，使用当前工作目录
            if not os.path.exists(desktop_path):
                desktop_path = os.getcwd()
                print(f"警告: 无法找到桌面路径，将使用当前工作目录: {desktop_path}")

            self.output_folder = os.path.join(desktop_path, 'inventory_warning_reports')
            print(f"报告将保存至: {self.output_folder}")
        except Exception as e:
            # 如果无法确定桌面路径，使用当前目录
            self.output_folder = os.path.join(os.getcwd(), 'inventory_warning_reports')
            print(f"警告: 无法确定桌面路径 ({str(e)}), 将使用当前目录: {self.output_folder}")

        # 创建输出文件夹
        try:
            if not os.path.exists(self.output_folder):
                os.makedirs(self.output_folder)
                print(f"已创建输出文件夹: {self.output_folder}")
        except Exception as e:
            print(f"警告: 无法创建输出文件夹 ({str(e)}), 尝试使用备用路径")
            # 尝试使用Python脚本所在的目录
            self.output_folder = os.path.dirname(os.path.abspath(__file__))
            print(f"将使用脚本所在目录: {self.output_folder}")

        # 颜色定义
        self.risk_colors = {
            '极高风险': '#FF0000',  # 红色
            '高风险': '#FF5252',  # 浅红色
            '中风险': '#FFC107',  # 黄色
            '低风险': '#4CAF50',  # 绿色
            '极低风险': '#2196F3'  # 蓝色
        }

    def load_data(self):
        """加载和预处理所有数据文件"""
        print("正在加载数据...")

        # 检查必要文件是否存在
        for file_name, file_path in [
            ("库存文件", self.inventory_file),
            ("出货数据文件", self.shipping_file),
            ("预测文件", self.forecast_file)
        ]:
            if not os.path.exists(file_path):
                raise FileNotFoundError(f"{file_name}不存在: {file_path}")

        print(f"文件检查通过，开始读取数据...")

        # 1.加载库存数据
        inventory_raw = pd.read_excel(self.inventory_file, header=0)

        # 处理第一层数据（产品信息）
        product_rows = inventory_raw[inventory_raw.iloc[:, 0].notna()]
        self.inventory_data = product_rows.iloc[:, :7].copy()
        self.inventory_data.columns = ['产品代码', '描述', '现有库存', '已分配量',
                                       '现有库存可订量', '待入库量', '本月剩余可订量']

        # 处理第二层数据（批次信息）
        batch_rows = inventory_raw[inventory_raw.iloc[:, 7].notna()]
        self.batch_data = batch_rows.iloc[:, 7:].copy()
        self.batch_data.columns = ['库位', '生产日期', '生产批号', '数量']

        # 为批次数据添加产品代码
        product_code = None
        product_description = None
        batch_with_product = []

        for i, row in inventory_raw.iterrows():
            if pd.notna(row.iloc[0]):
                # 这是产品行
                product_code = row.iloc[0]
                product_description = row.iloc[1]  # 获取产品描述
            elif pd.notna(row.iloc[7]):
                # 这是批次行
                batch_row = row.iloc[7:].copy()
                batch_row_with_product = pd.Series([product_code, product_description] + batch_row.tolist())
                batch_with_product.append(batch_row_with_product)

        self.batch_data = pd.DataFrame(batch_with_product)
        self.batch_data.columns = ['产品代码', '描述', '库位', '生产日期', '生产批号', '数量']

        # 转换日期列
        self.batch_data['生产日期'] = pd.to_datetime(self.batch_data['生产日期'])

        # 2.加载出货数据
        self.shipping_data = pd.read_excel(self.shipping_file, header=0)
        self.shipping_data.columns = ['订单日期', '所属区域', '申请人', '产品代码', '数量']

        # 转换日期列
        self.shipping_data['订单日期'] = pd.to_datetime(self.shipping_data['订单日期'])

        # 确保所有数值列为数字类型
        self.shipping_data['数量'] = pd.to_numeric(self.shipping_data['数量'], errors='coerce')
        self.shipping_data = self.shipping_data.dropna(subset=['数量'])

        # 将空的申请人替换为默认责任人
        self.shipping_data['申请人'] = self.shipping_data['申请人'].fillna(self.default_person)

        # 将空的区域替换为默认区域
        self.shipping_data['所属区域'] = self.shipping_data['所属区域'].fillna(self.default_region)

        # 3.加载预测数据
        self.forecast_data = pd.read_excel(self.forecast_file, header=0)

        # 调整预测数据的格式
        if len(self.forecast_data.columns) == 1:
            # 如果是单列，尝试拆分
            columns = ['所属大区', '销售员', '所属年月', '产品代码', '预计销售量']
            self.forecast_data = pd.DataFrame([
                row.split() for row in self.forecast_data.iloc[:, 0]
            ], columns=columns)
            self.forecast_data['预计销售量'] = self.forecast_data['预计销售量'].astype(float)
        else:
            self.forecast_data.columns = ['所属大区', '销售员', '所属年月', '产品代码', '预计销售量']

        # 转换日期列
        self.forecast_data['所属年月'] = pd.to_datetime(self.forecast_data['所属年月'])

        # 确保预计销售量为数字类型
        self.forecast_data['预计销售量'] = pd.to_numeric(self.forecast_data['预计销售量'], errors='coerce')
        self.forecast_data = self.forecast_data.dropna(subset=['预计销售量'])

        # 将空的大区替换为默认区域
        self.forecast_data['所属大区'] = self.forecast_data['所属大区'].fillna(self.default_region)

        # 将空的销售员替换为默认责任人
        self.forecast_data['销售员'] = self.forecast_data['销售员'].fillna(self.default_person)

        # 4.加载单价数据（如果提供）
        self.price_data = {}
        if self.price_file and os.path.exists(self.price_file):
            try:
                price_df = pd.read_excel(self.price_file)
                # 将单价数据转换为字典
                for _, row in price_df.iterrows():
                    self.price_data[row['产品代码']] = row['单价']
                print(f"成功加载单价数据，包含 {len(self.price_data)} 个产品的价格信息")
            except Exception as e:
                print(f"警告: 单价数据加载失败: {str(e)}")
                print("将使用默认单价(50)进行计算")
        else:
            # 指定的产品单价信息
            specified_prices = {
                'F01E4B': 137.04,
                'F3411A': 137.04,
                'F0104L': 126.72,
                'F3406B': 129.36,
                'F01C5D': 153.6,
                'F01L3A': 182.4,
                'F01L6A': 307.2,
                'F01A3C': 175.5,
                'F01H2B': 307.2,
                'F01L4A': 182.4,
                'F0104J': 216.96
            }
            self.price_data = specified_prices
            print("使用指定的产品单价信息")

        # 5. 建立销售人员-区域映射 (新增)
        self.create_person_region_mapping()

        # 6.创建产品-区域-责任人映射表
        self.create_product_responsibility_mapping()

        # 7.模拟订单历史数据（实际应用中应该从订单系统获取）
        # 在真实环境下，这部分数据应该从ERP或订单系统中获取
        print("模拟订单历史数据...")
        self.simulate_order_history()

        # 8.新增：创建历史预测准确率数据
        self.create_historical_forecast_accuracy()

        print("数据加载完成！")
        print(f"产品数量: {len(self.inventory_data)}")
        print(f"批次数量: {len(self.batch_data)}")
        print(f"出货记录数量: {len(self.shipping_data)}")
        print(f"预测记录数量: {len(self.forecast_data)}")
        print(f"单价数据数量: {len(self.price_data)}")
        print(f"订单历史记录: {len(self.orders_data)}")

    def create_person_region_mapping(self):
        """创建销售人员与区域的对应关系，确保责任人与区域匹配"""
        print("创建销售人员与区域的映射关系...")

        # 从出货数据中提取销售人员-区域对应关系
        person_region_data = self.shipping_data[['申请人', '所属区域']].drop_duplicates()

        # 统计每个销售人员最常出现的区域
        person_region_counts = self.shipping_data.groupby(['申请人', '所属区域']).size().unstack(fill_value=0)

        # 初始化映射字典
        self.sales_person_region_mapping = {}

        # 对于每个销售人员，找出他们最常用的区域
        for person in self.shipping_data['申请人'].unique():
            # 修改：系统管理员对应区域为空字符串
            if person == self.default_person:
                self.sales_person_region_mapping[person] = ""
            elif person in person_region_counts.index:
                # 找出该人员最常见的区域
                most_common_region = person_region_counts.loc[person].idxmax()
                self.sales_person_region_mapping[person] = most_common_region
            else:
                # 如果没有记录，使用默认区域
                self.sales_person_region_mapping[person] = self.default_region

        # 检查是否有销售人员在不同记录中关联了不同区域，并进行标准化
        inconsistent_mappings = []
        for person, region_data in self.shipping_data.groupby('申请人')['所属区域']:
            # 跳过系统管理员
            if person == self.default_person:
                continue

            unique_regions = region_data.unique()
            if len(unique_regions) > 1:
                inconsistent_mappings.append((person, unique_regions))
                # 使用出现频率最高的区域
                most_common = region_data.value_counts().idxmax()
                self.sales_person_region_mapping[person] = most_common

        if inconsistent_mappings:
            print(f"发现{len(inconsistent_mappings)}个销售人员在不同记录中关联了不同区域，已标准化为最常用区域")

        # 对预测数据中的销售员也添加区域映射
        for person in self.forecast_data['销售员'].unique():
            # 跳过已处理的系统管理员
            if person == self.default_person:
                continue

            if person not in self.sales_person_region_mapping:
                # 在预测数据中查找该销售员的区域
                person_regions = self.forecast_data[self.forecast_data['销售员'] == person]['所属大区'].unique()
                if len(person_regions) > 0:
                    self.sales_person_region_mapping[person] = person_regions[0]
                else:
                    self.sales_person_region_mapping[person] = self.default_region

        # 确保系统管理员的区域为空字符串
        self.sales_person_region_mapping[self.default_person] = ""

        print(f"已建立{len(self.sales_person_region_mapping)}个销售人员-区域映射关系")

    def create_product_responsibility_mapping(self):
        """创建产品与责任区域、责任人的映射关系"""
        self.product_responsibility = {}

        # 基于出货数据创建产品-区域-责任人映射
        product_region_counts = self.shipping_data.groupby(['产品代码', '所属区域']).size().unstack(fill_value=0)
        product_person_counts = self.shipping_data.groupby(['产品代码', '申请人']).size().unstack(fill_value=0)

        # 对于每个产品，找出最频繁的区域和责任人
        for product_code in self.inventory_data['产品代码'].unique():
            if product_code in product_region_counts.index:
                # 找出该产品最常见的区域
                top_region = product_region_counts.loc[product_code].idxmax()

                # 找出该产品中，该区域最常见的责任人
                region_persons = self.shipping_data[
                    (self.shipping_data['产品代码'] == product_code) &
                    (self.shipping_data['所属区域'] == top_region)
                    ]['申请人'].value_counts()

                if not region_persons.empty:
                    top_person = region_persons.index[0]
                elif product_code in product_person_counts.index:
                    # 如果没找到该区域的责任人，则使用该产品最常见的责任人
                    top_person = product_person_counts.loc[product_code].idxmax()
                else:
                    # 如果没有任何相关记录，使用默认值
                    top_person = self.default_person
            else:
                # 如果产品没有出货记录，使用默认值
                top_region = self.default_region
                top_person = self.default_person

            # 保存映射关系
            # 修改：如果责任人是系统管理员，区域设为空字符串
            if top_person == self.default_person:
                self.product_responsibility[product_code] = {
                    "region": "",
                    "person": top_person
                }
            else:
                self.product_responsibility[product_code] = {
                    "region": top_region,
                    "person": top_person
                }

                # 确保责任人与区域一致（使用我们之前建立的映射）
                if top_person in self.sales_person_region_mapping:
                    # 更新为标准化后的区域
                    self.product_responsibility[product_code]["region"] = self.sales_person_region_mapping[top_person]

    def simulate_order_history(self):
        """
        从出货数据创建订单历史数据，优先使用真实数据
        在真实环境中，这部分数据应该从ERP系统或订单数据库中获取
        """
        print("处理订单历史数据...")

        # 直接使用出货数据作为订单数据
        self.orders_data = self.shipping_data.copy()

        # 添加订单数量列，与出货数量相同
        self.orders_data['订单数量'] = self.orders_data['数量']

        print(f"使用实际出货数据作为订单历史，共{len(self.orders_data)}条记录")

    def create_historical_forecast_accuracy(self):
        """
        改进的历史预测准确率计算方法，基于实际数据并确保更合理的偏差分布
        """
        print("生成历史预测准确率数据...")

        # 获取所有产品和人员组合
        all_products = self.batch_data['产品代码'].unique()
        all_forecasters = self.forecast_data['销售员'].unique()

        # 初始化存储历史预测准确率的字典
        self.forecast_history = {}

        # 获取最近12个月的日期范围
        today = datetime.now().date()
        date_ranges = []
        for i in range(1, 13):  # 过去12个月
            # 计算上一个月的最后一天
            # 使用当月第一天减去一天的方式获取上个月最后一天，避免日期无效问题
            year = today.year - ((today.month - i) // 12)
            month = ((today.month - i) % 12) or 12
            # 获取下个月的第一天
            if month == 12:
                next_month_year = year + 1
                next_month = 1
            else:
                next_month_year = year
                next_month = month + 1
            # 下个月第一天减去1天就是当月最后一天
            end_date = datetime(next_month_year, next_month, 1).date() - timedelta(days=1)
            # 当月第一天
            start_date = datetime(year, month, 1).date()
            date_ranges.append((start_date, end_date))

        # 为每个产品-人员组合生成历史预测准确率
        for product_code in all_products:
            self.forecast_history[product_code] = {}

            # 获取该产品的实际销售数据
            product_sales = self.shipping_data[self.shipping_data['产品代码'] == product_code]

            # 获取该产品的预测数据
            product_forecast = self.forecast_data[self.forecast_data['产品代码'] == product_code]

            # 为每个销售员计算历史预测准确率
            for person in all_forecasters:
                # 首先尝试使用实际数据计算预测准确率
                bias_history = []
                has_real_data = False

                if person in product_forecast['销售员'].values:
                    person_forecast = product_forecast[product_forecast['销售员'] == person]

                    for start_date, end_date in date_ranges:
                        # 该期间的实际销售
                        period_sales = product_sales[
                            (product_sales['订单日期'].dt.date >= start_date) &
                            (product_sales['订单日期'].dt.date <= end_date)
                            ]['数量'].sum()

                        # 该期间的预测
                        period_forecast = person_forecast[
                            (person_forecast['所属年月'].dt.date >= start_date) &
                            (person_forecast['所属年月'].dt.date <= end_date)
                            ]['预计销售量'].sum()

                        # 如果有预测和销售数据，计算偏差
                        if period_forecast > 0 or period_sales > 0:
                            has_real_data = True

                            # 改进的偏差计算
                            if period_sales == 0 and period_forecast == 0:
                                bias = 0.0
                            elif period_sales == 0:
                                # 有预测无销售，限制最大偏差为80%
                                bias = min(0.8, period_forecast / max(1, period_forecast + 1))
                            elif period_forecast == 0:
                                # 无预测有销售，限制最大负偏差为80%
                                bias = max(-0.8, -period_sales / max(1, period_sales + 1))
                            else:
                                # 对称平均绝对百分比误差(SMAPE)变体
                                bias = (period_forecast - period_sales) / ((period_forecast + period_sales) / 2)

                                # 限制范围在-0.8到0.8之间
                                bias = max(-0.8, min(0.8, bias))

                            bias_history.append(bias)
                        elif len(bias_history) > 0:
                            # 如果有历史偏差，使用历史偏差的随机扰动
                            mean_bias = np.mean(bias_history)
                            std_bias = max(0.05, np.std(bias_history))
                            new_bias = np.random.normal(mean_bias, std_bias)
                            bias_history.append(max(-0.8, min(0.8, new_bias)))
                        else:
                            # 无数据时使用更合理的随机分布，避免集中在60%附近
                            # 使用实际分布数据的统计特性生成随机值
                            bias_history.append(np.random.uniform(-0.3, 0.4))

                # 如果没有足够的历史数据，生成更合理的随机数据
                if not has_real_data or len(bias_history) < 3:
                    # 生成随机偏差，使用更广泛的分布，避免集中在60%
                    bias_options = np.concatenate([
                        np.linspace(-0.7, -0.1, 7),  # 负偏差，更均匀分布
                        np.linspace(-0.05, 0.05, 3),  # 接近零偏差
                        np.linspace(0.1, 0.7, 7)  # 正偏差，更均匀分布
                    ])
                    np.random.seed(hash(f"{product_code}_{person}") % 10000)  # 确保可重复但不同组合有不同结果
                    bias_history = list(np.random.choice(bias_options, size=6, replace=True))

                # 确保有6个月的数据
                while len(bias_history) < 6:
                    if bias_history:
                        mean_bias = np.mean(bias_history)
                        new_bias = mean_bias + np.random.uniform(-0.2, 0.2)
                        bias_history.append(max(-0.8, min(0.8, new_bias)))
                    else:
                        bias_history.append(np.random.uniform(-0.4, 0.4))

                # 只保留最近6个月的数据
                bias_history = bias_history[-6:]

                # 计算平均偏差和趋势
                avg_bias = np.mean(bias_history)
                recent_bias = bias_history[-1]

                # 判断预测准确率趋势
                first_half = bias_history[:3]
                second_half = bias_history[3:]

                first_half_avg = np.mean([abs(b) for b in first_half])
                second_half_avg = np.mean([abs(b) for b in second_half])

                if second_half_avg < first_half_avg * 0.8:
                    accuracy_trend = 'improving'  # 偏差减小，准确率提高
                elif second_half_avg > first_half_avg * 1.2:
                    accuracy_trend = 'declining'  # 偏差增大，准确率下降
                else:
                    accuracy_trend = 'stable'  # 稳定

                # 存储结果
                self.forecast_history[product_code][person] = {
                    'avg_bias': avg_bias,
                    'bias_history': bias_history,
                    'recent_bias': recent_bias,
                    'accuracy_trend': accuracy_trend,
                    'is_real_data': has_real_data  # 标记是否使用了实际数据
                }

        print(f"已生成{len(self.forecast_history)}个产品的历史预测准确率数据")

    def calculate_risk_percentage(self, days_to_clear, batch_age, target_days):
        """
进一步优化的风险计算方法，更合理地考虑库龄与清库天数

参数:
days_to_clear (float): 预计清库天数
batch_age (int): 批次库龄（天数）
target_days (int): 目标清库天数（30/60/90天）

返回:
float: 风险百分比，范围0-100
"""
        # 核心规则1: 库龄已经超过目标天数，风险直接为100%
        if batch_age >= target_days:
            return 100.0

        # 核心规则2: 无法清库情况
        if days_to_clear == float('inf'):
            return 100.0

        # 核心规则3: 清库天数超过目标的3倍，风险为100%
        if days_to_clear >= 3 * target_days:
            return 100.0

        # 计算基于清库天数的风险（使用sigmoid函数提供更好的区分度）
        clearance_ratio = days_to_clear / target_days
        clearance_risk = 100 / (1 + math.exp(-4 * (clearance_ratio - 1)))

        # 计算基于库龄的风险（线性比例）
        age_risk = 100 * batch_age / target_days

        # 组合风险 - 加权平均，更强调高风险因素
        combined_risk = 0.8 * max(clearance_risk, age_risk) + 0.2 * min(clearance_risk, age_risk)

        # 阈值规则1: 清库天数超过目标，风险至少为80%
        if days_to_clear > target_days:
            combined_risk = max(combined_risk, 80)

        # 阈值规则2: 清库天数超过目标的2倍，风险至少为90%
        if days_to_clear >= 2 * target_days:
            combined_risk = max(combined_risk, 90)

        # 阈值规则3: 库龄超过目标的75%，风险至少为75%
        if batch_age >= 0.75 * target_days:
            combined_risk = max(combined_risk, 75)

        return min(100, round(combined_risk, 1))

    def calculate_forecast_bias(self, forecast_quantity, actual_sales, product_code=None, person=None):
        """
改进的预测偏差计算方法，使用滚动预测准确率进行偏差纠正与多因素校准

参数:
forecast_quantity (float): 预测销量
actual_sales (float): 实际销量
product_code (str): 产品代码，用于获取历史预测准确率
person (str): 销售人员，用于获取个人历史预测准确率

返回:
float: 预测偏差比例（正值表示预测高于实际，负值表示预测低于实际）
"""
        # 当前期间的预测偏差计算
        if actual_sales == 0 and forecast_quantity == 0:
            current_bias = 0.0  # 无预测无销售，无偏差
        elif actual_sales == 0:
            # 有预测无销售，根据预测量大小返回有上限的偏差
            # 改进: 降低极端偏差值，使用sqrt函数平滑大数值效应
            current_bias = min(math.sqrt(forecast_quantity) / (forecast_quantity), self.max_forecast_bias)
        elif forecast_quantity == 0:
            # 无预测有销售，返回负偏差
            current_bias = -min(math.sqrt(actual_sales) / (actual_sales), self.max_forecast_bias)
        else:
            # 使用均方根百分比误差(RMSPE)变体，对大小误差更敏感
            if forecast_quantity > actual_sales:
                # 预测过高
                normalized_error = (forecast_quantity - actual_sales) / actual_sales
                # 使用非线性衰减函数，降低大数值效应
                current_bias = min(math.tanh(normalized_error), self.max_forecast_bias)
            else:
                # 预测过低
                normalized_error = (actual_sales - forecast_quantity) / forecast_quantity
                # 同样使用非线性衰减
                current_bias = -min(math.tanh(normalized_error), self.max_forecast_bias)

        # 如果提供了产品代码和销售人员，结合历史准确率
        if product_code and person and self.forecast_history:
            # 获取历史预测准确率
            product_history = self.forecast_history.get(product_code, {})
            person_history = product_history.get(person, None)

            if person_history:
                # 基于历史准确率特征进行加权
                trend_factor = 1.0
                if person_history['accuracy_trend'] == 'improving':
                    # 如果准确率提高，增加当前偏差权重
                    trend_factor = 0.7  # 当前偏差权重
                elif person_history['accuracy_trend'] == 'declining':
                    # 如果准确率下降，增加历史偏差权重
                    trend_factor = 0.4  # 当前偏差权重
                else:
                    # 稳定状态
                    trend_factor = 0.6  # 当前偏差权重

                # 计算历史一致性
                historical_consistency = 1.0 - min(0.8, np.std(person_history['bias_history']) / 0.5)

                # 用于最终加权的因子
                recent_weight = trend_factor * historical_consistency

                # 使用加权组合：当前偏差、历史平均偏差和最近偏差
                combined_bias = (recent_weight * current_bias +
                                 (0.7 - recent_weight * 0.5) * person_history['avg_bias'] +
                                 (0.3 - recent_weight * 0.5) * person_history['recent_bias'])
                return combined_bias

        # 如果没有历史数据或未提供产品/人员信息，返回当前偏差
        return current_bias

    def analyze_responsibility_improved(self, product_code, batch_date, product_sales_metrics, forecast_info,
                                        orders_history):
        """
        改进的责任归属分析，重点关注预测与实际销售差异

        参数:
        product_code (str): 产品代码
        batch_date (datetime): 批次生产日期
        product_sales_metrics (dict): 产品销售指标
        forecast_info (dict): 预测信息
        orders_history (DataFrame): 订单历史

        返回:
        tuple: (主要责任区域, 主要责任人, 责任分析详情)
        """
        today = datetime.now().date()
        batch_date = batch_date.date()

        # 获取产品的默认责任映射
        default_mapping = self.product_responsibility.get(product_code,
                                                          {"region": self.default_region,
                                                           "person": self.default_person})

        # 1. 收集相关数据用于责任分析
        # ===============================

        # 1.1 获取批次生产前的预测记录 - 扩大时间窗口到90天
        forecast_start_date = batch_date - timedelta(days=90)  # 更长的预测回溯期
        forecast_end_date = batch_date + timedelta(days=30)  # 包括批次生产后的短期预测

        # 获取相关预测记录
        product_forecasts = self.forecast_data[
            (self.forecast_data['产品代码'] == product_code) &
            (self.forecast_data['所属年月'].dt.date >= forecast_start_date) &
            (self.forecast_data['所属年月'].dt.date <= forecast_end_date)
            ]

        # 1.2 获取批次生产后的实际销售记录 - 追踪销售履行情况
        sales_start_date = batch_date
        sales_end_date = min(today, batch_date + timedelta(days=90))  # 生产后90天或今天

        product_sales = self.shipping_data[
            (self.shipping_data['产品代码'] == product_code) &
            (self.shipping_data['订单日期'].dt.date >= sales_start_date) &
            (self.shipping_data['订单日期'].dt.date <= sales_end_date)
            ]

        # 2. 初始化责任评分系统
        # ===============================
        region_scores = {}
        person_scores = {}

        # 3. 核心责任因素：预测与实际销售差异分析 (60%)
        # ===============================
        forecast_sales_discrepancy_weight = 0.60  # 提高权重至60%

        if not product_forecasts.empty:
            # 按销售人员分组统计预测总量
            person_forecast_totals = product_forecasts.groupby('销售员')['预计销售量'].sum()

            # 按销售人员分组统计实际销售总量
            person_sales = {}
            for person in person_forecast_totals.index:
                # 获取该销售人员的实际销售记录
                person_actual_sales = product_sales[product_sales['申请人'] == person]['数量'].sum() \
                    if not product_sales.empty else 0
                person_sales[person] = person_actual_sales

                # 计算该人员的预测-销售差异率
                forecast_qty = person_forecast_totals[person]
                if forecast_qty > 0:
                    # 关键指标：销售履行率 = 实际销售/预测销售
                    fulfillment_rate = person_actual_sales / forecast_qty if forecast_qty > 0 else 1.0

                    # 判定责任 - 预测高但销售低的情况责任更大
                    # 销售履行率越低，责任分数越高
                    if fulfillment_rate < 0.5:  # 销售不到预测的50%
                        responsibility_score = forecast_sales_discrepancy_weight * (1 - fulfillment_rate) * 2
                    elif fulfillment_rate < 0.8:  # 销售不到预测的80%
                        responsibility_score = forecast_sales_discrepancy_weight * (1 - fulfillment_rate) * 1.5
                    else:  # 销售基本符合预测
                        responsibility_score = forecast_sales_discrepancy_weight * (1 - fulfillment_rate) * 0.5

                    # 加入预测量因素 - 预测量越大，影响越大
                    forecast_proportion = forecast_qty / person_forecast_totals.sum()
                    responsibility_score *= (0.5 + 0.5 * forecast_proportion)

                    # 更新人员责任分数
                    person_scores[person] = person_scores.get(person, 0) + responsibility_score

                    # 获取该人员的区域
                    person_region = self.sales_person_region_mapping.get(person, default_mapping["region"])
                    region_scores[person_region] = region_scores.get(person_region, 0) + (responsibility_score * 0.8)

        # 4. 次要责任因素：销售响应及时性 (25%)
        # ===============================
        sales_response_weight = 0.25

        if not product_forecasts.empty and not product_sales.empty:
            # 计算从批次生产到首次销售的响应时间
            first_sales_dates = product_sales.groupby('申请人')['订单日期'].min()

            for person in first_sales_dates.index:
                first_sale_date = first_sales_dates[person].date()
                response_days = (first_sale_date - batch_date).days

                # 销售响应及时性评分 - 响应越慢责任越大
                if response_days > 45:  # 45天以上才有首次销售
                    timeliness_score = sales_response_weight * 1.0
                elif response_days > 30:  # 30-45天有首次销售
                    timeliness_score = sales_response_weight * 0.8
                elif response_days > 15:  # 15-30天有首次销售
                    timeliness_score = sales_response_weight * 0.5
                else:  # 15天内有销售响应
                    timeliness_score = sales_response_weight * 0.2

                # 更新人员责任分数
                person_scores[person] = person_scores.get(person, 0) + timeliness_score

                # 获取该人员的区域
                person_region = self.sales_person_region_mapping.get(person, default_mapping["region"])
                region_scores[person_region] = region_scores.get(person_region, 0) + (timeliness_score * 0.8)

        # 5. 辅助责任因素：订单历史与批次产生关联度 (15%)
        # ===============================
        ordering_relation_weight = 0.15

        # 获取批次生产前的订单记录
        pre_batch_orders = self.orders_data[
            (self.orders_data['产品代码'] == product_code) &
            (self.orders_data['订单日期'].dt.date <= batch_date) &
            (self.orders_data['订单日期'].dt.date >= batch_date - timedelta(days=60))
            ]

        if not pre_batch_orders.empty:
            # 按人员统计订单量
            person_order_totals = pre_batch_orders.groupby('申请人')['订单数量'].sum()
            total_orders = person_order_totals.sum()

            for person, order_qty in person_order_totals.items():
                # 订单占比
                order_proportion = order_qty / total_orders

                # 责任评分 - 订单比例越高，责任越大
                order_score = ordering_relation_weight * order_proportion

                # 更新人员责任分数
                person_scores[person] = person_scores.get(person, 0) + order_score

                # 获取该人员的区域
                person_region = self.sales_person_region_mapping.get(person, default_mapping["region"])
                region_scores[person_region] = region_scores.get(person_region, 0) + (order_score * 0.8)

        # 6. 如果没有找到足够责任信息，使用默认责任
        # ===============================
        if not person_scores:
            # 如果没有有效的预测和销售数据，使用默认责任人
            person_scores[default_mapping["person"]] = 1.0
            region_scores[default_mapping["region"]] = 1.0

        # 7. 确定最终责任人和区域
        # ===============================
        if person_scores:
            responsible_person = max(person_scores.items(), key=lambda x: x[1])[0]

            # 获取该人员的标准区域
            if responsible_person in self.sales_person_region_mapping:
                responsible_region = self.sales_person_region_mapping[responsible_person]
            else:
                # 如果找不到映射，使用得分最高的区域
                responsible_region = max(region_scores.items(), key=lambda x: x[1])[0] if region_scores else \
                default_mapping["region"]
        else:
            responsible_person = default_mapping["person"]
            responsible_region = default_mapping["region"]

        # 8. 构建责任分析详情
        # ===============================
        # 获取次要责任人 - 得分超过最高分80%的人员
        top_person_score = max(person_scores.values()) if person_scores else 0
        secondary_persons = [p for p, s in person_scores.items()
                             if s >= top_person_score * 0.8 and p != responsible_person][:2]

        # 获取次要责任区域
        top_region_score = max(region_scores.values()) if region_scores else 0
        secondary_regions = [r for r, s in region_scores.items()
                             if s >= top_region_score * 0.8 and r != responsible_region][:2]

        # 构建详细分析信息
        responsibility_details = {
            "responsible_person": responsible_person,
            "responsible_region": responsible_region,
            "secondary_persons": secondary_persons,
            "secondary_regions": secondary_regions,
            "person_scores": person_scores,
            "region_scores": region_scores,
            "forecast_sales_analysis": {
                "person_forecasts": {p: f for p, f in
                                     person_forecast_totals.items()} if 'person_forecast_totals' in locals() else {},
                "person_actual_sales": person_sales if 'person_sales' in locals() else {},
                "fulfillment_rates": {
                    p: (person_sales.get(p, 0) / f) if f > 0 else 1.0
                    for p, f in person_forecast_totals.items()
                } if 'person_forecast_totals' in locals() else {}
            },
            "response_timeliness": {
                p: (first_sales_dates[p].date() - batch_date).days
                for p in first_sales_dates.index
            } if 'first_sales_dates' in locals() else {},
            "batch_info": {
                "batch_date": batch_date,
                "batch_age": (today - batch_date).days
            }
        }

        return (responsible_region, responsible_person, responsibility_details)

    def analyze_responsibility_collaborative(self, product_code, batch_date, product_sales_metrics, forecast_info,
                                             orders_history, batch_qty=0):
        """
        改进的责任归属分析，支持多人责任共担机制
        同时在debug模式下记录预测量计算的详细过程，用于解释

        参数:
        product_code (str): 产品代码
        batch_date (datetime): 批次生产日期
        product_sales_metrics (dict): 产品销售指标
        forecast_info (dict): 预测信息
        orders_history (DataFrame): 订单历史
        batch_qty (float): 批次库存数量，默认为0

        返回:
        tuple: (主要责任区域, 主要责任人, 责任分析详情)
        """
        today = datetime.now().date()
        batch_date = batch_date.date()

        # 获取产品的默认责任映射
        default_mapping = self.product_responsibility.get(product_code,
                                                          {"region": self.default_region,
                                                           "person": self.default_person})

        # 1. 收集相关数据用于责任分析
        # ===============================

        # 1.1 获取批次生产前后的预测记录
        # 确定计算窗口：批次日期前90天到后30天
        forecast_start_date = batch_date - timedelta(days=90)
        forecast_end_date = batch_date + timedelta(days=30)

        # 记录计算窗口的详细信息，用于说明预测量计算过程
        forecast_window_info = {
            "batch_date": batch_date,
            "window_start": forecast_start_date,
            "window_end": forecast_end_date,
            "calculation_logic": "系统计算预测量时，会查找批次生产日期前90天到批次生产日期后30天这个时间窗口内的所有预测记录"
        }

        # 获取相关预测记录
        product_forecasts = self.forecast_data[
            (self.forecast_data['产品代码'] == product_code) &
            (self.forecast_data['所属年月'].dt.date >= forecast_start_date) &
            (self.forecast_data['所属年月'].dt.date <= forecast_end_date)
            ]

        # 记录预测记录的详细信息，用于说明预测量计算过程
        forecast_records = []
        if not product_forecasts.empty:
            # 按月份分组记录
            monthly_forecasts = product_forecasts.groupby(product_forecasts['所属年月'].dt.strftime('%Y-%m'))[
                '预计销售量'].sum()

            for month, total in monthly_forecasts.items():
                forecast_records.append({
                    "month": month,
                    "forecast_quantity": total
                })

        # 1.2 获取批次生产后的实际销售记录
        sales_start_date = batch_date
        sales_end_date = min(today, batch_date + timedelta(days=90))

        # 记录销售窗口的详细信息
        sales_window_info = {
            "window_start": sales_start_date,
            "window_end": sales_end_date,
            "calculation_logic": "系统计算实际销量时，会查找批次生产日期到今天(或批次生产日期后90天，取较小值)这个时间窗口内的所有实际出货记录"
        }

        product_sales = self.shipping_data[
            (self.shipping_data['产品代码'] == product_code) &
            (self.shipping_data['订单日期'].dt.date >= sales_start_date) &
            (self.shipping_data['订单日期'].dt.date <= sales_end_date)
            ]

        # 2. 初始化责任评分系统
        # ===============================
        person_scores = {}
        region_scores = {}
        responsibility_details = {}

        # 3. 多人预测与销售差异分析 (60%)
        # ===============================
        forecast_sales_discrepancy_weight = 0.60

        # 存储详细的评分计算过程
        forecast_responsibility_details = {}

        if not product_forecasts.empty:
            # 计算批次相关的总预测量 (所有人员)
            total_forecast = product_forecasts['预计销售量'].sum()

            # 计算批次相关的总实际销量
            total_actual_sales = product_sales['数量'].sum() if not product_sales.empty else 0

            # 总体履行率
            overall_fulfillment_rate = total_actual_sales / total_forecast if total_forecast > 0 else 1.0

            # 按销售人员分组统计预测总量
            person_forecast_totals = product_forecasts.groupby('销售员')['预计销售量'].sum()

            # 按销售人员分组统计实际销售总量
            person_sales = {}
            for person in person_forecast_totals.index:
                # 获取该销售人员的实际销售记录
                person_actual_sales = product_sales[product_sales['申请人'] == person]['数量'].sum() \
                    if not product_sales.empty else 0
                person_sales[person] = person_actual_sales

            # 记录总体预测和销售信息
            responsibility_details["overall_analysis"] = {
                "total_forecast": total_forecast,
                "total_sales": total_actual_sales,
                "fulfillment_rate": overall_fulfillment_rate,
                "forecast_window": forecast_window_info,
                "sales_window": sales_window_info,
                "forecast_records": forecast_records
            }

            # 如果整体履行率低于80%，说明存在库存积压问题
            if overall_fulfillment_rate < 0.8:
                # 为每个预测者分配责任
                for person, forecast_qty in person_forecast_totals.items():
                    # 该人员的预测占总预测的比例
                    forecast_proportion = forecast_qty / total_forecast

                    # 该人员的实际销售量
                    actual_sales = person_sales.get(person, 0)

                    # 该人员的销售履行率
                    fulfillment_rate = actual_sales / forecast_qty if forecast_qty > 0 else 1.0

                    # 计算基础责任分数 - 基于个人履行率和预测占比
                    # 1. 个人履行率越低，责任越大
                    # 2. 预测占比越高，责任越大
                    base_score = (1 - fulfillment_rate) * forecast_proportion

                    # 根据预测量大小和履行率调整责任权重
                    if forecast_proportion > 0.5:  # 主要预测者
                        if fulfillment_rate < 0.6:  # 履行率很低
                            adjusted_score = base_score * 2.0
                        else:  # 履行率尚可
                            adjusted_score = base_score * 1.5
                    elif forecast_proportion > 0.2:  # 重要预测者
                        if fulfillment_rate < 0.6:  # 履行率很低
                            adjusted_score = base_score * 1.5
                        else:  # 履行率尚可
                            adjusted_score = base_score * 1.2
                    else:  # 次要预测者
                        adjusted_score = base_score * 1.0

                    # 计算最终责任分数
                    final_score = adjusted_score * forecast_sales_discrepancy_weight

                    # 更新人员责任分数
                    person_scores[person] = person_scores.get(person, 0) + final_score

                    # 获取该人员的区域
                    person_region = self.sales_person_region_mapping.get(person, default_mapping["region"])
                    region_scores[person_region] = region_scores.get(person_region, 0) + (final_score * 0.8)

                    # 记录详细计算过程
                    forecast_responsibility_details[person] = {
                        "forecast_quantity": forecast_qty,
                        "forecast_proportion": forecast_proportion,
                        "actual_sales": actual_sales,
                        "fulfillment_rate": fulfillment_rate,
                        "responsibility_score": final_score,
                        "calculation_factors": {
                            "base_score": base_score,
                            "adjustment_factor": adjusted_score / base_score if base_score > 0 else 1.0
                        }
                    }

            responsibility_details["forecast_responsibility"] = forecast_responsibility_details

        # 4. 销售响应及时性分析 (25%)
        # ===============================
        sales_response_weight = 0.25
        response_responsibility_details = {}

        if not product_sales.empty:
            # 计算从批次生产到首次销售的响应时间
            first_sales_dates = product_sales.groupby('申请人')['订单日期'].min()

            for person in first_sales_dates.index:
                first_sale_date = first_sales_dates[person].date()
                response_days = (first_sale_date - batch_date).days

                # 销售响应及时性评分 - 响应越慢责任越大
                if response_days > 45:  # 45天以上才有首次销售
                    timeliness_score = sales_response_weight * 1.0
                elif response_days > 30:  # 30-45天有首次销售
                    timeliness_score = sales_response_weight * 0.8
                elif response_days > 15:  # 15-30天有首次销售
                    timeliness_score = sales_response_weight * 0.5
                else:  # 15天内有销售响应
                    timeliness_score = sales_response_weight * 0.2

                # 更新人员责任分数
                person_scores[person] = person_scores.get(person, 0) + timeliness_score

                # 获取该人员的区域
                person_region = self.sales_person_region_mapping.get(person, default_mapping["region"])
                region_scores[person_region] = region_scores.get(person_region, 0) + (timeliness_score * 0.8)

                # 记录详细信息
                response_responsibility_details[person] = {
                    "first_sale_date": first_sale_date,
                    "response_days": response_days,
                    "timeliness_score": timeliness_score
                }

        responsibility_details["response_responsibility"] = response_responsibility_details

        # 5. 订单历史与批次关联度 (15%)
        # ===============================
        ordering_relation_weight = 0.15
        order_responsibility_details = {}

        # 获取批次生产前的订单记录
        pre_batch_orders = self.orders_data[
            (self.orders_data['产品代码'] == product_code) &
            (self.orders_data['订单日期'].dt.date <= batch_date) &
            (self.orders_data['订单日期'].dt.date >= batch_date - timedelta(days=60))
            ]

        if not pre_batch_orders.empty:
            # 按人员统计订单量
            person_order_totals = pre_batch_orders.groupby('申请人')['订单数量'].sum()
            total_orders = person_order_totals.sum()

            for person, order_qty in person_order_totals.items():
                # 订单占比
                order_proportion = order_qty / total_orders

                # 责任评分 - 订单比例越高，责任越大
                order_score = ordering_relation_weight * order_proportion

                # 更新人员责任分数
                person_scores[person] = person_scores.get(person, 0) + order_score

                # 获取该人员的区域
                person_region = self.sales_person_region_mapping.get(person, default_mapping["region"])
                region_scores[person_region] = region_scores.get(person_region, 0) + (order_score * 0.8)

                # 记录详细信息
                order_responsibility_details[person] = {
                    "order_quantity": order_qty,
                    "order_proportion": order_proportion,
                    "order_score": order_score
                }

        responsibility_details["order_responsibility"] = order_responsibility_details

        # 6. 责任共担机制 - 确定多个责任人
        # ===============================

        # 如果没有找到足够责任信息，使用默认责任
        if not person_scores:
            person_scores[default_mapping["person"]] = 1.0
            region_scores[default_mapping["region"]] = 1.0

        # ========== 修改：改进库存责任分配逻辑 ==========
        # 计算库存责任分配
        person_allocations = {}
        if forecast_responsibility_details and batch_qty > 0:
            # 1. 创建预测差值字典：计算每人预测与实际销售的差额
            forecast_deltas = {}
            total_delta = 0
            for person, details in forecast_responsibility_details.items():
                forecast_qty = details.get("forecast_quantity", 0)
                actual_sales = details.get("actual_sales", 0)
                # 计算"未兑现的预测"，即预测量超出实际销售的部分
                delta = max(0, forecast_qty - actual_sales)

                # 只有预测大于实际销售的人才承担直接责任
                if delta > 0:
                    forecast_deltas[person] = delta
                    total_delta += delta

            # 2. 按预测差值分配库存（基于"谁预测谁负责"原则）
            if total_delta > 0:
                # 第一轮：按未兑现的预测量分配库存
                allocated_total = 0
                for person, delta in forecast_deltas.items():
                    # 按差值比例分配
                    proportion = delta / total_delta
                    allocation = int(batch_qty * proportion)
                    # 确保结果合理
                    allocation = max(1, allocation)
                    allocation = min(allocation, batch_qty - allocated_total)

                    person_allocations[person] = allocation
                    allocated_total += allocation

                # 检查是否还有剩余库存未分配
                remaining_qty = batch_qty - allocated_total

                # 如果所有有预测的人分配完后还有剩余，将剩余部分按比例再分配给有预测的人
                if remaining_qty > 0 and forecast_deltas:
                    # 按比例分配剩余部分
                    remaining_allocated = 0
                    sorted_forecast_persons = sorted(forecast_deltas.items(), key=lambda x: x[1], reverse=True)

                    for i, (person, _) in enumerate(sorted_forecast_persons):
                        if i == len(sorted_forecast_persons) - 1:
                            # 最后一人获得所有剩余
                            person_allocations[person] += (remaining_qty - remaining_allocated)
                        else:
                            additional = int(remaining_qty * (forecast_deltas[person] / total_delta))
                            additional = max(0, additional)
                            additional = min(additional, remaining_qty - remaining_allocated)
                            person_allocations[person] += additional
                            remaining_allocated += additional
            else:
                # 如果没有正的预测差值，找出有预测的人按预测量比例分配
                forecasters = {p: details.get("forecast_quantity", 0)
                               for p, details in forecast_responsibility_details.items()
                               if details.get("forecast_quantity", 0) > 0}

                if forecasters:
                    total_forecast = sum(forecasters.values())
                    allocated_total = 0

                    for person, forecast_qty in sorted(forecasters.items(), key=lambda x: x[1], reverse=True):
                        if len(forecasters) == 1:
                            # 只有一个预测者，获得全部数量
                            person_allocations[person] = batch_qty
                        else:
                            # 按预测比例分配
                            proportion = forecast_qty / total_forecast
                            allocation = int(batch_qty * proportion)
                            # 确保结果合理
                            allocation = max(1, allocation)
                            allocation = min(allocation, batch_qty - allocated_total)

                            person_allocations[person] = allocation
                            allocated_total += allocation

                    # 确保所有库存都分配完毕
                    if allocated_total < batch_qty and forecasters:
                        # 将剩余库存分配给预测量最高的人
                        top_forecaster = max(forecasters.items(), key=lambda x: x[1])[0]
                        person_allocations[top_forecaster] += (batch_qty - allocated_total)
                else:
                    # 如果完全没有预测者，分配给主要责任人
                    person_allocations[default_mapping["person"]] = batch_qty
        else:
            # 如果没有预测数据，但有得分的人，找出有得分且有预测的人
            forecasters = {}
            for person, score in person_scores.items():
                # 检查是否有预测记录
                forecast_qty = 0
                if forecast_responsibility_details and person in forecast_responsibility_details:
                    forecast_qty = forecast_responsibility_details[person].get("forecast_quantity", 0)

                # 只有有预测的人才计入
                if forecast_qty > 0:
                    forecasters[person] = score

            if forecasters:
                # 有预测者，按得分分配
                total_score = sum(forecasters.values())
                allocated_total = 0

                for person, score in sorted(forecasters.items(), key=lambda x: x[1], reverse=True):
                    if len(forecasters) == 1:
                        # 只有一个预测者，获得全部数量
                        person_allocations[person] = batch_qty
                    else:
                        # 按得分比例分配
                        proportion = score / total_score
                        allocation = int(batch_qty * proportion)
                        # 确保结果合理
                        allocation = max(1, allocation)
                        allocation = min(allocation, batch_qty - allocated_total)

                        person_allocations[person] = allocation
                        allocated_total += allocation

                # 确保所有库存都分配完毕
                if allocated_total < batch_qty and forecasters:
                    # 将剩余库存分配给得分最高的人
                    top_scorer = max(forecasters.items(), key=lambda x: x[1])[0]
                    person_allocations[top_scorer] += (batch_qty - allocated_total)
            elif person_scores:
                # 如果没有预测者，但有责任得分的人（通常不应该发生）
                # 将所有库存分配给主要责任人
                person_allocations[default_mapping["person"]] = batch_qty
            else:
                # 完全没有相关人员，使用默认责任人
                person_allocations[default_mapping["person"]] = batch_qty

        # ========== 修改：改为基于库存分配量确定主要责任人 ==========
        # 根据应承担库存数量确定主要责任人，而不是责任得分
        if person_allocations:
            # 找出应承担库存数量最多的人作为主要责任人
            responsible_person = max(person_allocations.items(), key=lambda x: x[1])[0]

            # 获取该人员的标准区域
            if responsible_person in self.sales_person_region_mapping:
                # 修改：如果是系统管理员，区域留空
                if responsible_person == self.default_person:
                    responsible_region = ""
                else:
                    responsible_region = self.sales_person_region_mapping[responsible_person]
            else:
                # 如果找不到映射，使用得分最高的区域
                responsible_region = max(region_scores.items(), key=lambda x: x[1])[0] if region_scores else \
                    default_mapping["region"]
                # 如果是系统管理员，区域留空
                if responsible_person == self.default_person:
                    responsible_region = ""
        else:
            responsible_person = default_mapping["person"]
            # 如果是系统管理员，区域留空
            if responsible_person == self.default_person:
                responsible_region = ""
            else:
                responsible_region = default_mapping["region"]

        # 确定共同责任人 - 得分超过最高分60%的人员都算共同责任人
        # 这里降低阈值，从原来的80%降低到60%，以便纳入更多责任共担者
        responsible_persons = list(person_allocations.keys())

        # 限制共同责任人数量，但确保至少包含得分最高的人
        if len(responsible_persons) > 5:
            # 按库存分配量排序
            sorted_persons = sorted([(p, person_allocations[p]) for p in responsible_persons],
                                    key=lambda x: x[1], reverse=True)
            responsible_persons = [p[0] for p in sorted_persons[:5]]

        # 次要责任人 - 主要责任人之外的其他责任人
        secondary_persons = [p for p in responsible_persons if p != responsible_person]

        # 区域责任
        responsible_regions = []
        for p in responsible_persons:
            if p == self.default_person:
                # 系统管理员不添加区域
                continue
            region = self.sales_person_region_mapping.get(p, default_mapping["region"])
            if region and region not in responsible_regions:
                responsible_regions.append(region)

        # 次要责任区域
        secondary_regions = [r for r in responsible_regions if r != responsible_region]

        # 7. 构建最终责任分析详情
        # ===============================

        responsibility_analysis = {
            "responsible_person": responsible_person,
            "responsible_region": responsible_region,
            "responsible_persons": responsible_persons,
            "secondary_persons": secondary_persons,
            "responsible_regions": responsible_regions,
            "secondary_regions": secondary_regions,
            "person_scores": person_scores,
            "region_scores": region_scores,
            "responsibility_details": responsibility_details,
            "quantity_allocation": {
                "batch_qty": batch_qty,
                "person_allocations": person_allocations,
                "allocation_logic": "责任库存严格基于预测未兑现量(预测-实际销量)分配，预测量为0的人不承担任何库存责任"
            },
            "batch_info": {
                "batch_date": batch_date,
                "batch_age": (today - batch_date).days,
                "batch_qty": batch_qty  # 存储批次数量信息
            },
            # 新增：预测计算详细说明
            "forecast_calculation_detail": {
                "window": forecast_window_info,
                "records": forecast_records,
                "description": "系统按完整月份计算窗口期内的所有预测量总和。"
            }
        }

        return (responsible_region, responsible_person, responsibility_analysis)

    def analyze_data(self):
        """分析数据并生成指标"""
        print("正在分析数据...")

        # 为每个产品批次计算关键指标
        batch_analysis = []
        today = datetime.now().date()

        # 计算每个产品的销售指标
        product_sales_metrics = {}
        for product_code in self.inventory_data['产品代码'].unique():
            # 获取该产品的销售记录
            product_sales = self.shipping_data[self.shipping_data['产品代码'] == product_code]

            if len(product_sales) == 0:
                # 无销售记录
                product_sales_metrics[product_code] = {
                    'daily_avg_sales': 0,
                    'sales_std': 0,
                    'coefficient_of_variation': float('inf'),
                    'total_sales': 0,
                    'last_90_days_sales': 0,
                    'region_sales': {},
                    'person_sales': {}
                }
            else:
                # 计算日均销量
                total_sales = product_sales['数量'].sum()

                # 计算过去90天的销量
                ninety_days_ago = today - timedelta(days=90)
                recent_sales = product_sales[product_sales['订单日期'].dt.date >= ninety_days_ago]
                recent_sales_total = recent_sales['数量'].sum() if len(recent_sales) > 0 else 0

                # 计算日均销量
                # 使用从最早订单到今天的天数作为分母
                days_range = (today - product_sales['订单日期'].min().date()).days + 1
                daily_avg_sales = total_sales / days_range if days_range > 0 else 0

                # 计算日销量标准差
                # 首先构建每日销量时间序列
                daily_sales = product_sales.groupby(product_sales['订单日期'].dt.date)['数量'].sum()

                # 计算标准差
                sales_std = daily_sales.std() if len(daily_sales) > 1 else 0

                # 计算变异系数（波动系数）
                coefficient_of_variation = sales_std / daily_avg_sales if daily_avg_sales > 0 else float('inf')

                # 按区域和销售人员分组统计
                region_sales = product_sales.groupby('所属区域')['数量'].sum().to_dict()
                person_sales = product_sales.groupby('申请人')['数量'].sum().to_dict()

                # 存储结果
                product_sales_metrics[product_code] = {
                    'daily_avg_sales': daily_avg_sales,
                    'sales_std': sales_std,
                    'coefficient_of_variation': coefficient_of_variation,
                    'total_sales': total_sales,
                    'last_90_days_sales': recent_sales_total,
                    'region_sales': region_sales,
                    'person_sales': person_sales
                }

        # 计算每个产品的季节性指数
        # 简化计算：使用过去12个月的数据，按月计算季节性
        seasonal_indices = {}
        for product_code in self.inventory_data['产品代码'].unique():
            product_sales = self.shipping_data[self.shipping_data['产品代码'] == product_code]

            if len(product_sales) > 0:
                # 按月分组销量
                product_sales['月份'] = product_sales['订单日期'].dt.month
                monthly_sales = product_sales.groupby('月份')['数量'].sum()

                if len(monthly_sales) > 1:
                    # 计算平均月销量
                    avg_monthly_sales = monthly_sales.mean()

                    # 当前月份的季节性指数
                    current_month = today.month
                    if current_month in monthly_sales.index:
                        seasonal_index = monthly_sales[current_month] / avg_monthly_sales
                    else:
                        seasonal_index = 1.0  # 无数据时默认为1
                else:
                    seasonal_index = 1.0  # 只有一个月的数据，无法计算季节性
            else:
                seasonal_index = 1.0  # 无销售数据默认为1

            # 应用季节性指数下限，避免因季节性极低导致的问题
            seasonal_index = max(seasonal_index, self.min_seasonal_index)
            seasonal_indices[product_code] = seasonal_index

        # 计算每个产品的预测准确度（改进版 - 使用滚动预测准确率）
        forecast_accuracy = {}
        for product_code in self.inventory_data['产品代码'].unique():
            product_forecast = self.forecast_data[self.forecast_data['产品代码'] == product_code]

            if len(product_forecast) > 0:
                # 获取预测销量
                forecast_quantity = product_forecast['预计销售量'].sum()

                # 获取实际销量（最近一个月）
                one_month_ago = today - timedelta(days=30)
                product_recent_sales = self.shipping_data[
                    (self.shipping_data['产品代码'] == product_code) &
                    (self.shipping_data['订单日期'].dt.date >= one_month_ago)
                    ]

                # 修复：确保实际销量有合理值
                actual_sales = product_recent_sales['数量'].sum() if not product_recent_sales.empty else 0

                # 使用改进的预测偏差计算方法 - 考虑历史预测准确率
                forecast_bias = self.calculate_forecast_bias(forecast_quantity, actual_sales, product_code)

                # 按区域分组的预测
                region_forecast = product_forecast.groupby('所属大区')['预计销售量'].sum().to_dict()

                # 按销售员分组的预测
                person_forecast = product_forecast.groupby('销售员')['预计销售量'].sum().to_dict()

                # 改进: 计算每个销售员的预测偏差
                person_bias = {}
                for person, forecast_qty in person_forecast.items():
                    # 获取该销售员的历史预测准确率
                    if self.forecast_history and product_code in self.forecast_history and person in \
                            self.forecast_history[product_code]:
                        person_history = self.forecast_history[product_code][person]
                        # 使用历史平均偏差和当前预测占比计算个人偏差
                        if sum(person_forecast.values()) > 0:
                            weight = forecast_qty / sum(person_forecast.values())
                            # 获取该人员的最近销售记录
                            person_recent_sales = product_recent_sales[product_recent_sales['申请人'] == person][
                                '数量'].sum() \
                                if not product_recent_sales.empty else 0
                            # 计算个人预测偏差
                            person_bias[person] = self.calculate_forecast_bias(
                                forecast_qty, person_recent_sales, product_code, person)
                        else:
                            person_bias[person] = person_history['recent_bias']
                    else:
                        # 无历史数据时使用整体偏差和预测占比
                        if sum(person_forecast.values()) > 0:
                            weight = forecast_qty / sum(person_forecast.values())
                            person_bias[person] = forecast_bias * weight
                        else:
                            person_bias[person] = 0
            else:
                # 无预测数据时
                forecast_bias = 0.0  # 默认无偏差
                region_forecast = {}
                person_forecast = {}
                person_bias = {}

            forecast_accuracy[product_code] = {
                'forecast_bias': forecast_bias,
                'region_forecast': region_forecast,
                'person_forecast': person_forecast,
                'person_bias': person_bias  # 新增：每个销售员的预测偏差
            }

        # 计算每个批次的指标
        for _, batch in self.batch_data.iterrows():
            product_code = batch['产品代码']
            description = batch['描述']
            batch_date = batch['生产日期']
            batch_qty = batch['数量']

            # 计算库龄（从生产日期到今天的天数）
            batch_age = (today - batch_date.date()).days

            # 获取销售指标
            sales_metrics = product_sales_metrics.get(product_code, {
                'daily_avg_sales': 0,
                'sales_std': 0,
                'coefficient_of_variation': float('inf'),
                'total_sales': 0,
                'last_90_days_sales': 0,
                'region_sales': {},
                'person_sales': {}
            })

            # 获取季节性指数
            seasonal_index = seasonal_indices.get(product_code, 1.0)

            # 获取预测准确度
            forecast_info = forecast_accuracy.get(product_code, {
                'forecast_bias': 0.0,
                'region_forecast': {},
                'person_forecast': {},
                'person_bias': {}
            })

            # 获取产品单价并计算批次价值
            # 使用价格数据字典查找单价，如果不存在则使用默认值50
            unit_price = self.price_data.get(product_code, 50.0)
            batch_value = batch_qty * unit_price

            # 计算预计清库天数
            daily_avg_sales = sales_metrics['daily_avg_sales']

            # 考虑季节性调整，并应用最小销量阈值
            daily_avg_sales_adjusted = max(daily_avg_sales * seasonal_index, self.min_daily_sales)

            # 计算清库天数和积压风险
            if daily_avg_sales_adjusted > 0:
                days_to_clear = batch_qty / daily_avg_sales_adjusted

                # 使用改进的风险计算方法
                one_month_risk = self.calculate_risk_percentage(days_to_clear, batch_age, 30)
                two_month_risk = self.calculate_risk_percentage(days_to_clear, batch_age, 60)
                three_month_risk = self.calculate_risk_percentage(days_to_clear, batch_age, 90)
            else:
                days_to_clear = float('inf')
                one_month_risk = 100
                two_month_risk = 100
                three_month_risk = 100

            # 使用基于多人责任共担的责任归属分析方法，传递批次库存数量
            responsible_region, responsible_person, responsibility_details = self.analyze_responsibility_collaborative(
                product_code, batch_date, sales_metrics, forecast_info, self.orders_data, batch_qty
            )

            # 计算销量占比（该产品销量在所有产品中的占比）
            total_all_sales = sum([metrics['total_sales'] for metrics in product_sales_metrics.values()])
            product_total_sales = sales_metrics['total_sales']
            sales_proportion = (product_total_sales / total_all_sales * 100) if total_all_sales > 0 else 0

            # 确定积压原因
            stocking_reasons = []
            if batch_age > 60:
                stocking_reasons.append("库龄过长")
            if sales_metrics['coefficient_of_variation'] > self.high_volatility_threshold:
                stocking_reasons.append("销量波动大")
            if seasonal_index < 0.8:
                stocking_reasons.append("季节性影响")
            if abs(forecast_info['forecast_bias']) > self.high_forecast_bias_threshold:
                stocking_reasons.append("预测偏差大")
            if not stocking_reasons:
                stocking_reasons.append("正常库存")

            # 改进风险等级评估逻辑 - 使用综合评分方法
            risk_score = 0

            # 库龄因素 (0-40分)
            if batch_age > 90:
                risk_score += 40
            elif batch_age > 60:
                risk_score += 30
            elif batch_age > 30:
                risk_score += 20
            else:
                risk_score += 10

            # 清库天数因素 (0-40分)
            if days_to_clear == float('inf'):
                risk_score += 40
            elif days_to_clear > 180:  # 半年以上
                risk_score += 35
            elif days_to_clear > 90:
                risk_score += 30
            elif days_to_clear > 60:
                risk_score += 20
            elif days_to_clear > 30:
                risk_score += 10

            # 销量波动系数 (0-10分)
            if sales_metrics['coefficient_of_variation'] > 2.0:
                risk_score += 10
            elif sales_metrics['coefficient_of_variation'] > 1.0:
                risk_score += 5

            # 预测偏差 (0-10分) - 使用绝对值评估偏差大小
            if abs(forecast_info['forecast_bias']) > 0.5:  # 50%以上偏差
                risk_score += 10
            elif abs(forecast_info['forecast_bias']) > 0.3:  # 30%以上偏差
                risk_score += 8
            elif abs(forecast_info['forecast_bias']) > 0.15:  # 15%以上偏差
                risk_score += 5

            # 根据总分确定风险等级
            if risk_score >= 80:
                risk_level = "极高风险"
            elif risk_score >= 60:
                risk_level = "高风险"
            elif risk_score >= 40:
                risk_level = "中风险"
            elif risk_score >= 20:
                risk_level = "低风险"
            else:
                risk_level = "极低风险"

            # 生成建议措施
            if risk_level == "极高风险":
                recommendation = "紧急清理：考虑折价促销"
            elif risk_level == "高风险":
                recommendation = "优先处理：降价促销或转仓调配"
            elif risk_level == "中风险":
                recommendation = "密切监控：调整采购计划"
            elif risk_level == "低风险":
                recommendation = "常规管理：定期审查库存周转"
            else:
                recommendation = "维持现状：正常库存水平"

            # 格式化预测偏差为百分比
            forecast_bias_value = forecast_info['forecast_bias']
            if forecast_bias_value == float('inf'):
                forecast_bias_pct = "无穷大"
            elif forecast_bias_value == 0:
                forecast_bias_pct = "0%"
            else:
                # 转换为易于理解的百分比格式，正负值表示方向
                forecast_bias_pct = f"{round(forecast_bias_value * 100, 1)}%"

            # 生成责任分析摘要 - 使用修改后的函数，确保与责任判定详情一致
            responsibility_summary = self.generate_responsibility_summary_collaborative(responsibility_details)

            # 将分析结果添加到列表
            batch_analysis.append({
                '物料': product_code,
                '描述': description,
                '批次日期': batch_date.date(),
                '批次库存': batch_qty,
                '库龄': batch_age,
                '批次价值': batch_value,
                '日均出货': round(daily_avg_sales, 2),
                '出货标准差': round(sales_metrics['sales_std'], 2),
                '出货波动系数': round(sales_metrics['coefficient_of_variation'], 2),
                '预计清库天数': days_to_clear if days_to_clear != float('inf') else float('inf'),
                '一个月积压风险': f"{round(one_month_risk, 1)}%",
                '两个月积压风险': f"{round(two_month_risk, 1)}%",
                '三个月积压风险': f"{round(three_month_risk, 1)}%",
                '积压原因': '，'.join(stocking_reasons),
                '季节性指数': round(seasonal_index, 2),
                '责任区域': responsible_region,
                '责任人': responsible_person,
                '责任详情': responsibility_details,  # 保存完整责任详情供摘要使用
                '责任分析摘要': responsibility_summary,  # 使用责任分析摘要函数生成
                '风险程度': risk_level,
                '风险得分': risk_score,
                '建议措施': recommendation
            })

        self.batch_analysis = pd.DataFrame(batch_analysis)

        # 按照风险程度和库龄排序
        risk_order = {
            "极高风险": 0,
            "高风险": 1,
            "中风险": 2,
            "低风险": 3,
            "极低风险": 4
        }
        self.batch_analysis['风险排序'] = self.batch_analysis['风险程度'].map(risk_order)
        self.batch_analysis = self.batch_analysis.sort_values(by=['风险排序', '库龄'], ascending=[True, False])
        self.batch_analysis = self.batch_analysis.drop(columns=['风险排序'])

        print("数据分析完成！")

    def generate_responsibility_summary_collaborative(self, responsibility_analysis):
        """
        根据责任分析详情生成强调多人责任共担的摘要
        增加责任人需要承担的具体库存数量信息，确保库存数量分配合理
        严格按照应承担库存数量降序排列显示
        """
        if not responsibility_analysis:
            return "无法确定责任"

        responsible_person = responsibility_analysis.get("responsible_person", self.default_person)
        secondary_persons = responsibility_analysis.get("secondary_persons", [])
        person_scores = responsibility_analysis.get("person_scores", {})
        responsibility_details = responsibility_analysis.get("responsibility_details", {})

        # 获取批次信息
        batch_info = responsibility_analysis.get("batch_info", {})
        batch_qty = batch_info.get("batch_qty", 0)  # 批次的总库存数量

        # 获取库存分配信息
        quantity_allocation = responsibility_analysis.get("quantity_allocation", {})
        person_allocations = quantity_allocation.get("person_allocations", {})

        # 获取预测责任详情
        forecast_responsibility = responsibility_details.get("forecast_responsibility", {})
        response_responsibility = responsibility_details.get("response_responsibility", {})
        order_responsibility = responsibility_details.get("order_responsibility", {})

        # 构建主要责任人的责任原因
        main_person_reasons = []

        # 检查主要责任人的预测情况
        has_forecast = False
        if responsible_person in forecast_responsibility:
            has_forecast = True
            person_forecast = forecast_responsibility[responsible_person]
            forecast_qty = person_forecast.get("forecast_quantity", 0)
            forecast_pct = person_forecast.get("forecast_proportion", 0) * 100
            actual_sales = person_forecast.get("actual_sales", 0)
            fulfillment = person_forecast.get("fulfillment_rate", 1.0) * 100
            unfulfilled = max(0, forecast_qty - actual_sales)

            # 修改：总是显示详细的预测和销售信息，不管条件如何
            if forecast_qty > 0:
                main_person_reasons.append(
                    f"预测{forecast_qty:.0f}件但仅销售{actual_sales:.0f}件(履行率{fulfillment:.0f}%)")

            # 仍然添加未兑现预测量
            if unfulfilled > 0:
                main_person_reasons.append(f"未兑现预测{unfulfilled:.0f}件")

        # 如果没有预测但有其他责任原因
        if not has_forecast:
            # 检查响应及时性
            if responsible_person in response_responsibility:
                days = response_responsibility[responsible_person].get("response_days", 0)
                if days > 30:
                    main_person_reasons.append(f"销售响应延迟({days}天)")

            # 检查订单历史
            if responsible_person in order_responsibility:
                order_qty = order_responsibility[responsible_person].get("order_quantity", 0)
                order_pct = order_responsibility[responsible_person].get("order_proportion", 0) * 100
                if order_pct > 20:
                    main_person_reasons.append(f"订单占比高({order_pct:.0f}%)")

        # 如果没有特定原因，添加一个通用原因
        if not main_person_reasons:
            main_person_reasons.append("综合预测与销售因素")

        # 构建其他责任人的摘要 - 包括所有次要责任人，即使没有库存分配
        other_persons_data = []

        # 处理次要责任人列表
        for person in secondary_persons:
            if person != responsible_person:
                allocated_qty = person_allocations.get(person, 0)

                # 获取责任原因
                reason = ""

                # 检查预测情况
                if person in forecast_responsibility:
                    forecast_info = forecast_responsibility[person]
                    forecast_qty = forecast_info.get("forecast_quantity", 0)
                    actual_sales = forecast_info.get("actual_sales", 0)
                    fulfillment = forecast_info.get("fulfillment_rate", 1.0) * 100
                    unfulfilled = max(0, forecast_qty - actual_sales)

                    # 修改：更详细的责任描述
                    if forecast_qty > 0 and fulfillment < 100:
                        reason = f"履行率低({fulfillment:.0f}%)"
                    if unfulfilled > 0:
                        # 使用未兑现预测量而不是履行率
                        reason = f"未兑现预测{unfulfilled:.0f}件"
                # 检查响应及时性
                elif person in response_responsibility:
                    days = response_responsibility[person].get("response_days", 0)
                    if days > 30:
                        reason = f"响应延迟({days}天)"
                    else:
                        reason = "有销售记录"
                # 检查订单历史
                elif person in order_responsibility:
                    reason = "订单关联"
                # 如果都没有，使用通用原因
                else:
                    reason = "责任共担"

                # 添加到待排序列表
                other_persons_data.append((person, reason, allocated_qty))

        # 确保也包括那些不在 secondary_persons 但在 person_allocations 中的人
        for person, allocated_qty in person_allocations.items():
            if person != responsible_person and person not in secondary_persons and allocated_qty > 0:
                # 获取责任原因，逻辑同上
                reason = ""
                if person in forecast_responsibility:
                    forecast_info = forecast_responsibility[person]
                    forecast_qty = forecast_info.get("forecast_quantity", 0)
                    actual_sales = forecast_info.get("actual_sales", 0)
                    fulfillment = forecast_info.get("fulfillment_rate", 1.0) * 100
                    unfulfilled = max(0, forecast_qty - actual_sales)

                    if forecast_qty > 0 and fulfillment < 100:
                        reason = f"履行率低({fulfillment:.0f}%)"
                    if unfulfilled > 0:
                        reason = f"未兑现预测{unfulfilled:.0f}件"
                elif person in response_responsibility:
                    days = response_responsibility[person].get("response_days", 0)
                    if days > 30:
                        reason = f"响应延迟({days}天)"
                    else:
                        reason = "有销售记录"
                elif person in order_responsibility:
                    reason = "订单关联"
                else:
                    reason = "责任共担"

                other_persons_data.append((person, reason, allocated_qty))

        # 严格按照应承担库存数量降序排序
        other_persons_data.sort(key=lambda x: x[2], reverse=True)

        # 转换为摘要文本
        other_persons_summary = [f"{person}({reason}，承担{qty}件)" for person, reason, qty in other_persons_data]

        # 生成最终摘要
        main_reason = "、".join(main_person_reasons)

        # 添加主要责任人需要承担的库存数量信息
        if responsible_person in person_allocations and person_allocations[responsible_person] > 0:
            main_responsibility_qty = person_allocations[responsible_person]
            main_person_with_qty = f"{responsible_person}主要责任({main_reason}，承担{main_responsibility_qty}件)"
        else:
            # 即使没有库存分配也添加0件
            main_person_with_qty = f"{responsible_person}主要责任({main_reason}，承担0件)"

        if other_persons_summary:
            others_text = "，".join(other_persons_summary)
            summary = f"{main_person_with_qty}，共同责任：{others_text}"
        else:
            summary = main_person_with_qty

        return summary

    def generate_excel_report(self, timestamp):
        """生成简化的Excel报告，移除预测偏差和责任分析摘要列，增加责任判定详情工作表"""
        report_path = os.path.join(self.output_folder, f'批次库存积压预警报告_{timestamp}.xlsx')

        print(f"准备生成Excel报告，共{len(self.batch_analysis)}条批次数据")

        try:
            # 创建Excel工作簿
            wb = Workbook()

            # 删除默认工作表
            wb.remove(wb.active)

            # 1.创建批次分析详情工作表（主要工作表）
            ws_details = wb.create_sheet("库存批次分析")

            # 添加标题
            ws_details.cell(row=1, column=1, value="批次级别库存积压预警分析")
            ws_details.cell(row=1, column=1).font = Font(bold=True, size=16)
            ws_details.merge_cells('A1:G1')

            # 添加生成日期
            ws_details.cell(row=2, column=1, value=f"生成日期: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            ws_details.merge_cells('A2:G2')

            # 添加风险统计
            extreme_high_risk_count = sum(self.batch_analysis['风险程度'] == '极高风险')
            high_risk_count = sum(self.batch_analysis['风险程度'] == '高风险')
            medium_risk_count = sum(self.batch_analysis['风险程度'] == '中风险')
            low_risk_count = sum(self.batch_analysis['风险程度'] == '低风险')
            extreme_low_risk_count = sum(self.batch_analysis['风险程度'] == '极低风险')

            ws_details.cell(row=4, column=1, value="风险等级分布：")
            ws_details.cell(row=5, column=1, value=f"极高风险批次: {extreme_high_risk_count}")
            ws_details.cell(row=5, column=1).font = Font(color="8B0000")  # 深红色
            ws_details.cell(row=6, column=1, value=f"高风险批次: {high_risk_count}")
            ws_details.cell(row=6, column=1).font = Font(color="FF0000")  # 红色
            ws_details.cell(row=7, column=1, value=f"中风险批次: {medium_risk_count}")
            ws_details.cell(row=7, column=1).font = Font(color="FFA500")  # 橙色
            ws_details.cell(row=8, column=1, value=f"低风险批次: {low_risk_count}")
            ws_details.cell(row=8, column=1).font = Font(color="008000")  # 绿色
            ws_details.cell(row=9, column=1, value=f"极低风险批次: {extreme_low_risk_count}")
            ws_details.cell(row=9, column=1).font = Font(color="0000FF")  # 蓝色

            # 空行
            ws_details.cell(row=11, column=1, value="全部批次分析明细：")
            ws_details.cell(row=11, column=1).font = Font(bold=True)

            # 修改：移除预测偏差和责任分析摘要列
            key_columns = [
                '物料', '描述', '批次日期', '批次库存', '库龄', '批次价值',
                '日均出货', '出货波动系数', '预计清库天数',
                '一个月积压风险', '两个月积压风险', '三个月积压风险', '积压原因', '季节性指数',
                '责任区域', '责任人', '责任分析摘要', '风险程度', '风险得分', '建议措施'
            ]

            batch_export = self.batch_analysis[key_columns].copy()

            # 处理特殊值
            batch_export['预计清库天数'] = batch_export['预计清库天数'].apply(
                lambda x: "∞" if x == float('inf') else round(x, 1)
            )

            print(f"开始写入Excel批次数据，共{len(batch_export)}行")

            # 使用dataframe_to_rows函数写入数据
            for r_idx, row in enumerate(dataframe_to_rows(batch_export, index=False, header=True), 12):
                for c_idx, value in enumerate(row, 1):
                    # 写入值到单元格
                    cell = ws_details.cell(row=r_idx, column=c_idx, value=value)

                    # 设置表头样式
                    if r_idx == 12:  # 表头行
                        cell.font = Font(bold=True)
                        cell.alignment = Alignment(horizontal='center', wrap_text=True)

            print("数据写入完成，开始设置单元格格式")

            # 为特定列添加样式
            for row_idx in range(13, len(batch_export) + 13):  # 从数据行开始
                # 设置风险程度列的颜色
                risk_cell = ws_details.cell(row=row_idx, column=key_columns.index('风险程度') + 1)
                risk_level = risk_cell.value
                if risk_level == '极高风险':
                    risk_cell.font = Font(color="8B0000", bold=True)
                elif risk_level == '高风险':
                    risk_cell.font = Font(color="FF0000", bold=True)
                elif risk_level == '中风险':
                    risk_cell.font = Font(color="FFA500")
                elif risk_level == '低风险':
                    risk_cell.font = Font(color="008000")
                elif risk_level == '极低风险':
                    risk_cell.font = Font(color="0000FF")

                # 设置库龄列的颜色
                age_cell = ws_details.cell(row=row_idx, column=key_columns.index('库龄') + 1)
                if age_cell.value:
                    age = age_cell.value
                    if age > 90:
                        age_cell.font = Font(color="8B0000")
                    elif age > 60:
                        age_cell.font = Font(color="FF0000")

                # 对预计清库天数进行颜色标记
                clearance_cell = ws_details.cell(row=row_idx, column=key_columns.index('预计清库天数') + 1)
                if clearance_cell.value == "∞":
                    clearance_cell.font = Font(color="8B0000", bold=True)
                elif isinstance(clearance_cell.value, (int, float)) and clearance_cell.value > 90:
                    clearance_cell.font = Font(color="FF0000")

                # 设置批次价值列的格式
                value_cell = ws_details.cell(row=row_idx, column=key_columns.index('批次价值') + 1)
                value_cell.number_format = '#,##0.00'
                # 高价值批次标记为重点关注
                if isinstance(value_cell.value, (int, float)) and value_cell.value > 10000:
                    value_cell.font = Font(color="8B0000", bold=True)

                # 积压风险列颜色标记
                for risk_col in ['一个月积压风险', '两个月积压风险', '三个月积压风险']:
                    risk_idx = key_columns.index(risk_col) + 1
                    risk_cell = ws_details.cell(row=row_idx, column=risk_idx)
                    if risk_cell.value and isinstance(risk_cell.value, str):
                        try:
                            risk_pct = float(risk_cell.value.rstrip('%'))
                            if risk_pct > 90:
                                risk_cell.font = Font(color="8B0000")
                            elif risk_pct > 75:
                                risk_cell.font = Font(color="FF0000")
                            elif risk_pct > 50:
                                risk_cell.font = Font(color="FFA500")
                        except:
                            pass

            # 自动调整列宽
            for column in range(1, len(key_columns) + 1):
                col_letter = get_column_letter(column)
                # 根据列内容设置合适的宽度
                max_length = 0
                for cell in ws_details[col_letter]:
                    if cell.value:
                        try:
                            cell_length = len(str(cell.value))
                            max_length = max(max_length, cell_length)
                        except:
                            pass

                    # 添加一些边距(约15%)，但对于长文本进行限制
                    adjusted_width = min(max_length + 2, 30)
                    ws_details.column_dimensions[col_letter].width = adjusted_width

            # 对特定列进行宽度调整
            desc_col = get_column_letter(key_columns.index('描述') + 1)
            ws_details.column_dimensions[desc_col].width = 30  # 描述列宽一些

            reason_col = get_column_letter(key_columns.index('积压原因') + 1)
            ws_details.column_dimensions[reason_col].width = 25  # 积压原因列较宽

            # 2. 创建责任判定详情工作表
            ws_responsibility = wb.create_sheet("责任判定详情")
            self.add_responsibility_details_sheet(ws_responsibility)

            # 3. 创建责任判定逻辑说明工作表
            ws_logic = wb.create_sheet("责任判定逻辑说明")
            self.add_responsibility_logic_sheet(ws_logic)

            # 4. 新增：创建责任判定流程图工作表
            ws_flowchart = wb.create_sheet("责任判定流程图")
            self.add_responsibility_flowchart_sheet(ws_flowchart)

            # 确保工作表作为默认打开的工作表
            wb.active = ws_details

            print(f"报告格式设置完成，准备保存到: {report_path}")

            # 保存Excel文件
            wb.save(report_path)
            print(f"Excel报告已成功生成: {report_path}")

            return report_path

        except Exception as e:
            print(f"Excel生成过程中发生错误: {str(e)}")
            import traceback
            traceback.print_exc()

            # 尝试使用备用路径保存
            try:
                alternate_path = os.path.join(self.output_folder, f'批次库存积压预警报告_{timestamp}_备用.xlsx')
                wb.save(alternate_path)
                print(f"已保存到备用位置: {alternate_path}")
                return alternate_path
            except:
                # 如果还是失败，尝试保存到当前目录
                try:
                    current_dir_path = os.path.join(os.getcwd(), f'批次库存积压预警报告_{timestamp}.xlsx')
                    wb.save(current_dir_path)
                    print(f"已保存到当前目录: {current_dir_path}")
                    return current_dir_path
                except Exception as e2:
                    print(f"所有保存尝试均失败: {str(e2)}")
                    return None

    def add_responsibility_details_sheet(self, worksheet):
        """
        创建责任判定详情工作表，展示每个批次的责任人得分计算过程
        并增加计算逻辑详细解释，让业务代表理解预测量和实际销量的计算方式
        以及增加库存责任数量分配逻辑解释
        """
        # 设置标题
        worksheet.cell(row=1, column=1, value="批次库存积压责任判定详细计算过程")
        worksheet.cell(row=1, column=1).font = Font(bold=True, size=16)
        worksheet.merge_cells('A1:J1')  # 增加一列

        # 添加说明 - 修改说明以强调库存分配逻辑
        worksheet.cell(row=2, column=1,
                       value="本表详细展示每个批次的责任人得分计算过程和库存分配方式，主要责任人基于应承担库存数量而非责任得分确定，增强责任判定的透明度和可解释性。")
        worksheet.cell(row=2, column=1).font = Font(italic=True)
        worksheet.merge_cells('A2:J2')  # 增加一列

        # 表头
        headers = [
            "批次编号", "物料", "批次日期", "责任人",
            "预测销售差异得分(60%)", "销售响应及时性得分(25%)", "订单历史关联得分(15%)",
            "总得分", "应承担库存数量", "计算详情"  # 新增"应承担库存数量"列
        ]

        for col, header in enumerate(headers, 1):
            cell = worksheet.cell(row=4, column=col, value=header)
            cell.font = Font(bold=True)
            cell.alignment = Alignment(horizontal='center', wrap_text=True)
            cell.fill = PatternFill(start_color="E0E0E0", end_color="E0E0E0", fill_type="solid")

        # 填充数据
        row_idx = 5
        batch_count = 0

        for i, batch in enumerate(self.batch_analysis.itertuples(), 1):
            try:
                product_code = batch.物料
                batch_date = batch.批次日期
                batch_qty = batch.批次库存  # 获取批次数量
                responsibility_details = batch.责任详情

                # 跳过没有责任详情的批次
                if not responsibility_details or not isinstance(responsibility_details, dict):
                    continue

                batch_count += 1

                # 获取责任详情
                person_scores = responsibility_details.get("person_scores", {})

                # 获取库存分配详情
                quantity_allocation = responsibility_details.get("quantity_allocation", {})
                person_allocations = quantity_allocation.get("person_allocations", {})

                # 获取详细分析数据
                responsibility_details_data = responsibility_details.get("responsibility_details", {})
                forecast_responsibility = responsibility_details_data.get("forecast_responsibility", {})
                response_responsibility = responsibility_details_data.get("response_responsibility", {})
                order_responsibility = responsibility_details_data.get("order_responsibility", {})

                # 创建人员详情列表，包含分配数量
                person_details = []
                for person, total_score in person_scores.items():
                    allocated_qty = person_allocations.get(person, 0)
                    person_details.append((person, total_score, allocated_qty))

                # 按照应承担库存数量降序排序
                person_details.sort(key=lambda x: (x[2], x[1]), reverse=True)

                # 记录每个责任人的得分详情
                for person, total_score, allocated_qty in person_details:
                    worksheet.cell(row=row_idx, column=1, value=batch_count)  # 批次编号
                    worksheet.cell(row=row_idx, column=2, value=product_code)  # 物料

                    # 批次日期处理
                    batch_date_str = str(batch_date) if batch_date else "未知"
                    worksheet.cell(row=row_idx, column=3, value=batch_date_str)  # 批次日期

                    worksheet.cell(row=row_idx, column=4, value=person)  # 责任人

                    # 预测销售差异得分
                    forecast_score = 0
                    if person in forecast_responsibility:
                        forecast_score = forecast_responsibility[person].get("responsibility_score", 0)
                    worksheet.cell(row=row_idx, column=5, value=round(forecast_score, 4))

                    # 销售响应及时性得分
                    response_score = 0
                    if person in response_responsibility:
                        response_score = response_responsibility[person].get("timeliness_score", 0)
                    worksheet.cell(row=row_idx, column=6, value=round(response_score, 4))

                    # 订单历史关联得分
                    order_score = 0
                    if person in order_responsibility:
                        order_score = order_responsibility[person].get("order_score", 0)
                    worksheet.cell(row=row_idx, column=7, value=round(order_score, 4))

                    # 总得分
                    worksheet.cell(row=row_idx, column=8, value=round(total_score, 4))

                    # 应承担库存数量
                    worksheet.cell(row=row_idx, column=9, value=allocated_qty)

                    # 计算详情
                    calculation_details = []

                    # 预测详情
                    if person in forecast_responsibility:
                        forecast_info = forecast_responsibility[person]
                        forecast_qty = forecast_info.get("forecast_quantity", 0)
                        forecast_pct = forecast_info.get("forecast_proportion", 0) * 100
                        actual_sales = forecast_info.get("actual_sales", 0)
                        fulfillment = forecast_info.get("fulfillment_rate", 1.0) * 100

                        forecast_detail = f"预测量:{forecast_qty:.1f}件(占比{forecast_pct:.1f}%)，实际销量:{actual_sales:.1f}件，履行率:{fulfillment:.1f}%"
                        calculation_details.append(forecast_detail)

                        # 添加未兑现预测量信息
                        if forecast_qty > actual_sales:
                            unfulfilled = forecast_qty - actual_sales
                            calculation_details.append(f"未兑现预测量:{unfulfilled:.1f}件")

                    # 响应及时性详情
                    if person in response_responsibility:
                        days = response_responsibility[person].get("response_days", 0)
                        response_detail = f"首次销售响应时间:{days}天"
                        calculation_details.append(response_detail)

                    # 订单历史详情
                    if person in order_responsibility:
                        order_qty = order_responsibility[person].get("order_quantity", 0)
                        order_pct = order_responsibility[person].get("order_proportion", 0) * 100
                        order_detail = f"订单量:{order_qty:.1f}件(占比{order_pct:.1f}%)"
                        calculation_details.append(order_detail)

                    # 添加库存分配计算详情
                    if person in person_allocations and allocated_qty > 0:
                        # 检查是否有预测未兑现量
                        if person in forecast_responsibility:
                            forecast_qty = forecast_responsibility[person].get("forecast_quantity", 0)
                            actual_sales = forecast_responsibility[person].get("actual_sales", 0)
                            unfulfilled = max(0, forecast_qty - actual_sales)

                            if unfulfilled > 0:
                                allocation_detail = f"库存责任分配:基于未兑现预测量{unfulfilled:.1f}件计算，分配{allocated_qty}件"
                            else:
                                allocation_detail = f"库存责任分配:基于责任得分比例{total_score:.4f}，分配{allocated_qty}件"
                        else:
                            allocation_detail = f"库存责任分配:基于责任得分比例{total_score:.4f}，分配{allocated_qty}件"

                        calculation_details.append(allocation_detail)

                    detail_text = "；".join(calculation_details)
                    worksheet.cell(row=row_idx, column=10, value=detail_text)

                    # 为分数较高的单元格添加颜色
                    if total_score > 0.5:
                        worksheet.cell(row=row_idx, column=8).font = Font(color="FF0000", bold=True)
                    elif total_score > 0.3:
                        worksheet.cell(row=row_idx, column=8).font = Font(color="FF8C00")

                    # 为主要责任人添加背景色 - 由于主要责任人定义已变更，需修改此处逻辑
                    if person == batch.责任人:
                        for col in range(1, 11):
                            worksheet.cell(row=row_idx, column=col).fill = PatternFill(
                                start_color="FFEBEE", end_color="FFEBEE", fill_type="solid")

                    row_idx += 1
            except Exception as e:
                print(f"处理批次{i}的责任详情时出错: {str(e)}")
                continue

        # 设置列宽
        column_widths = [10, 15, 15, 15, 15, 15, 15, 10, 12, 60]  # 修改列宽以适应新列
        for i, width in enumerate(column_widths):
            worksheet.column_dimensions[get_column_letter(i + 1)].width = width

        # 添加表格边框和交替行颜色
        for row in range(4, row_idx):
            for col in range(1, 11):  # 增加一列
                cell = worksheet.cell(row=row, column=col)
                cell.border = Border(
                    left=Side(style='thin'),
                    right=Side(style='thin'),
                    top=Side(style='thin'),
                    bottom=Side(style='thin')
                )

                # 为数据行添加交替背景色（主要责任人已单独着色，这里只处理非主要责任人）
                if row > 4 and row % 2 == 0 and not cell.fill.start_color.rgb:
                    cell.fill = PatternFill(start_color="F5F5F5", end_color="F5F5F5", fill_type="solid")

        # 添加统计信息
        summary_row = row_idx + 2
        worksheet.cell(row=summary_row, column=1,
                       value=f"统计信息: 共分析了{batch_count}个批次，{row_idx - 5}条责任记录")
        worksheet.cell(row=summary_row, column=1).font = Font(bold=True)
        worksheet.merge_cells(f'A{summary_row}:J{summary_row}')  # 增加一列

        # 添加库存责任分配逻辑解释
        explanation_start_row = summary_row + 3

        # 标题和分隔线
        worksheet.cell(row=explanation_start_row, column=1, value="库存责任数量分配逻辑详细说明")
        worksheet.cell(row=explanation_start_row, column=1).font = Font(bold=True, size=14)
        worksheet.merge_cells(f'A{explanation_start_row}:J{explanation_start_row}')  # 增加一列

        explanation_start_row += 1

        # 添加责任分配逻辑解释
        allocation_explanations = [
            ["1. 库存责任分配基本原则",
             "系统严格遵循\"谁预测谁负责\"原则，只有提交了预测并且预测未被完全兑现的人员才会被分配库存责任。预测量为0的人员不承担任何库存责任。",
             "E6BB8D", 12, True],

            ["预测责任优先的分配公式",
             "预测者应承担库存数量 = 批次总库存数量 × (该责任人未兑现预测量 ÷ 所有责任人未兑现预测量总和)",
             None, 11, False],

            ["预测量为0的人员处理",
             "预测量为0的人员完全不承担库存责任，即使他们有销售记录或订单历史。这是基于\"谁预测谁负责\"的核心原则，确保没有做出预测的人不需要承担由他人预测导致的库存积压。",
             None, 11, False],

            ["库存全分配保证",
             "所有库存都会被分配到有预测量的人员中。如果预测未兑现总量不足以覆盖全部库存，则按预测量比例将剩余库存分配给预测者。",
             None, 11, False],

            ["2. 特殊情况处理",
             "当主要责任人预测占比接近100%时，系统会将全部库存分配给该责任人。在完全没有预测记录的极端情况下，系统才会考虑分配给主要责任人。",
             "E6BB8D", 12, True],

            ["实际案例说明一：预测责任型",
             "以物料F01C5D、批次日期2024-09-10为例，批次库存532件：\n"
             "• 梁洪泽：预测量600件，实际销量266件，未兑现334件\n"
             "• 未兑现预测占总库存的比例: 334 ÷ 532 = 62.8%\n"
             "• 应承担库存数量: 532件(100%)\n",
             None, 11, False],

            ["实际案例说明二：多人预测型",
             "以物料F01H2B、批次日期2024-10-10为例，批次库存82件：\n"
             "• 谢剑峰：预测量90件，实际销量15件，未兑现75件，应承担34件\n"
             "• 孙杨：预测量160件，实际销量30件，未兑现130件，应承担48件\n"
             "• 宋述仑：预测量0件，不承担任何库存责任\n"
             "• 总计：所有库存82件全部分配给有预测的人员\n",
             None, 11, False],

            ["3. 责任承担的实际意义",
             "责任人应承担的库存数量代表其需要负责清理的实际库存量，严格基于未兑现的预测量分配责任，体现\"谁预测多，谁承担多\"的公平原则。系统定义应承担库存数量最多的人为主要责任人。",
             "E6BB8D", 12, True],

            ["4. 无预测无责任原则",
             "系统确保没有提交预测的人员不承担库存积压责任，预防了责任不当分配。这鼓励销售人员提交准确的预测，并对自己的预测负责。",
             "E6BB8D", 12, True],
        ]

        # 写入库存责任分配逻辑解释
        for idx, (subtitle, content, bgcolor, font_size, is_bold) in enumerate(allocation_explanations):
            current_row = explanation_start_row + idx

            # 写入小标题或内容
            subtitle_cell = worksheet.cell(row=current_row, column=1, value=subtitle)
            subtitle_cell.font = Font(bold=is_bold, size=font_size)

            # 如果有背景色，添加背景色
            if bgcolor:
                subtitle_cell.fill = PatternFill(start_color=bgcolor, end_color=bgcolor, fill_type="solid")

            # 写入内容文本
            content_cell = worksheet.cell(row=current_row, column=2, value=content)
            content_cell.font = Font(size=font_size)
            content_cell.alignment = Alignment(wrap_text=True, vertical='top')
            worksheet.merge_cells(f'B{current_row}:J{current_row}')  # 增加一列

            # 调整行高以适应内容
            if len(content) > 100:  # 如果内容较长
                worksheet.row_dimensions[current_row].height = max(60, len(content) // 8)  # 根据内容长度设置行高

        # 新增：预测量和实际销量计算窗口和方法说明
        prediction_explanation_row = explanation_start_row + len(allocation_explanations) + 2

        # 标题和分隔线
        worksheet.cell(row=prediction_explanation_row, column=1, value="预测量与实际销量计算逻辑详细说明")
        worksheet.cell(row=prediction_explanation_row, column=1).font = Font(bold=True, size=14)
        worksheet.merge_cells(f'A{prediction_explanation_row}:J{prediction_explanation_row}')

        prediction_explanation_row += 1

        # 计算逻辑说明 - 添加详细解释
        explanations = [
            ["1. 预测量计算窗口",
             "系统计算预测量时，会查找批次生产日期前90天到批次生产日期后30天这个时间窗口内的所有预测记录。例如批次生产日期是2024-12-19，则预测窗口为2024-09-20至2025-01-18。",
             "E6BB8D", 12, True],

            ["预测量计算方法",
             "系统会将时间窗口内所有月份的预测数据累加，得到总预测量。由于系统是按完整月份计算，所以会计算2024-10、2024-11、2024-12和2025-01这四个月的预测量总和。",
             None, 11, False],

            ["示例说明",
             "以物料F01H2A、销售员李根、批次日期2024-12-19为例：\n"
             "• 计算窗口：2024-09-20至2025-01-18\n"
             "• 包含月份：2024-10月(115件)、2024-11月(110件)、2024-12月(80件)、2025-01月(0件)\n"
             "• 预测总量：115 + 110 + 80 + 0 = 305件\n"
             "• 2024-09月的预测(40件)未计入总量，因为系统只考虑窗口内的完整月份",
             None, 11, False],

            ["2. 实际销量计算窗口",
             "系统计算实际销量时，会查找批次生产日期到今天(或批次生产日期后90天，取较小值)这个时间窗口内的所有实际出货记录。例如批次生产日期是2024-12-19，则销量窗口为2024-12-19至今。",
             "E6BB8D", 12, True],

            ["实际销量计算方法",
             "系统会计算窗口期内指定销售人员的所有该产品出货记录总和，作为实际销量。如果没有出货记录，则实际销量为0。",
             None, 11, False],

            ["3. 未兑现预测量计算",
             "未兑现预测量 = max(0, 预测量 - 实际销量)\n"
             "这是库存责任分配的核心指标，代表销售员预测但未能兑现的销售量。",
             "E6BB8D", 12, True],

            ["4. 预测销售差异得分计算",
             "基于未兑现预测量，系统计算销售人员的预测销售差异责任得分：\n"
             "• 未兑现率 = (预测量 - 实际销量) / 预测量 (仅当预测量 > 0 且 实际销量 < 预测量)\n"
             "• 预测比例 = 该销售员预测量 / 总预测量\n"
             "• 预测销售差异得分 = 60% × 未兑现率 × 预测比例 × 调整因子\n\n"
             "预测量越高、履行率越低，得分越高，表示责任越大。",
             "E6BB8D", 12, True],

            ["计算解释",
             "以李根的F01H2A批次为例：\n"
             "• 预测量305件，实际销量13件，未兑现292件\n"
             "• 未兑现率95.7%，预测占比26.5%\n"
             "• 预测销售差异得分 = 60% × 95.7% × 26.5% × 调整因子\n"
             "根据未兑现预测量比例，李根需要承担该批次的主要库存责任。",
             None, 11, False],

            ["5. 总结",
             "系统优先基于未兑现预测量分配库存责任，体现\"谁预测谁负责\"原则，同时考虑销售响应及时性和历史订单关联度，确保责任分配的公平合理。主要责任人定义为应承担库存数量最多的人。",
             "E6BB8D", 12, True],
        ]

        # 写入详细说明
        for idx, (subtitle, content, bgcolor, font_size, is_bold) in enumerate(explanations):
            current_row = prediction_explanation_row + idx

            # 写入小标题或内容
            subtitle_cell = worksheet.cell(row=current_row, column=1, value=subtitle)
            subtitle_cell.font = Font(bold=is_bold, size=font_size)

            # 如果有背景色，添加背景色
            if bgcolor:
                subtitle_cell.fill = PatternFill(start_color=bgcolor, end_color=bgcolor, fill_type="solid")

            # 写入内容文本
            content_cell = worksheet.cell(row=current_row, column=2, value=content)
            content_cell.font = Font(size=font_size)
            content_cell.alignment = Alignment(wrap_text=True, vertical='top')
            worksheet.merge_cells(f'B{current_row}:J{current_row}')

            # 调整行高以适应内容
            if len(content) > 100:  # 如果内容较长
                worksheet.row_dimensions[current_row].height = max(60, len(content) // 8)  # 根据内容长度设置行高

        # 添加注意事项
        note_row = prediction_explanation_row + len(explanations) + 1
        worksheet.cell(row=note_row, column=1, value="重要提示：")
        worksheet.cell(row=note_row, column=1).font = Font(bold=True, color="FF0000")

        worksheet.cell(row=note_row, column=2,
                       value="系统的库存责任分配以预测未兑现量为核心，体现\"谁预测谁负责\"原则。预测者的责任与其预测偏差直接相关，而非预测者不承担任何库存责任。这确保了责任分配的公平性和清晰性，同时避免了责任过度分散的问题。应承担库存数量最多的人被定义为主要责任人。")
        worksheet.cell(row=note_row, column=2).font = Font(italic=True)
        worksheet.merge_cells(f'B{note_row}:J{note_row}')

        # 添加具体案例计算示例
        final_row = self.add_calculation_example_section(worksheet, note_row + 2)

        print(
            f"责任判定详情工作表已创建，包含{batch_count}个批次，{row_idx - 5}条责任详情记录，并按承担库存数量降序排列，增加了详细的计算逻辑解释")

        return final_row

    def add_calculation_example_section(self, worksheet, explanation_end_row):
        """
        为责任判定详情工作表添加一个具体的计算示例，通过F01H2A产品李根的实际数据展示

        参数:
        worksheet: Excel工作表对象
        explanation_end_row: 前面解释部分结束的行号
        """
        example_start_row = explanation_end_row + 2

        # 示例部分标题
        worksheet.cell(row=example_start_row, column=1, value="F01H2A产品李根预测与销量对比实际计算示例")
        worksheet.cell(row=example_start_row, column=1).font = Font(bold=True, size=14)
        worksheet.merge_cells(f'A{example_start_row}:I{example_start_row}')
        worksheet.cell(row=example_start_row, column=1).fill = PatternFill(start_color="DAEEF3", end_color="DAEEF3",
                                                                           fill_type="solid")

        # 添加李根预测数据表格
        table_start_row = example_start_row + 2

        # 原始预测数据表格标题
        worksheet.cell(row=table_start_row, column=1, value="原始预测数据:")
        worksheet.cell(row=table_start_row, column=1).font = Font(bold=True)
        worksheet.merge_cells(f'A{table_start_row}:C{table_start_row}')

        # 表头
        headers = ["所属年月", "产品代码", "预计销售量"]
        for col, header in enumerate(headers, 1):
            worksheet.cell(row=table_start_row + 1, column=col, value=header).font = Font(bold=True)
            worksheet.cell(row=table_start_row + 1, column=col).fill = PatternFill(start_color="F2F2F2",
                                                                                   end_color="F2F2F2",
                                                                                   fill_type="solid")
            worksheet.cell(row=table_start_row + 1, column=col).border = Border(
                left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin')
            )

        # 李根的预测数据
        forecast_data = [
            ["2024-01", "F01H2A", 0],
            ["2024-02", "F01H2A", 30],
            ["2024-03", "F01H2A", 50],
            ["2024-04", "F01H2A", 50],
            ["2024-05", "F01H2A", 50],
            ["2024-06", "F01H2A", 40],
            ["2024-07", "F01H2A", 50],
            ["2024-08", "F01H2A", 30],
            ["2024-09", "F01H2A", 40],
            ["2024-10", "F01H2A", 115],
            ["2024-11", "F01H2A", 110],
            ["2024-12", "F01H2A", 80],
            ["2025-01", "F01H2A", 0],
            ["2025-02", "F01H2A", 20],
            ["2025-03", "F01H2A", 40]
        ]

        # 写入预测数据
        for row_idx, row_data in enumerate(forecast_data):
            for col_idx, cell_value in enumerate(row_data):
                worksheet.cell(row=table_start_row + 2 + row_idx, column=col_idx + 1, value=cell_value)
                worksheet.cell(row=table_start_row + 2 + row_idx, column=col_idx + 1).border = Border(
                    left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin')
                )

                # 高亮时间窗口内的月份
                if row_data[0] in ["2024-10", "2024-11", "2024-12", "2025-01"] and col_idx == 2:
                    worksheet.cell(row=table_start_row + 2 + row_idx, column=col_idx + 1).fill = PatternFill(
                        start_color="FFEB9C", end_color="FFEB9C", fill_type="solid"
                    )

        # 添加计算窗口说明
        calculation_row = table_start_row + len(forecast_data) + 3
        worksheet.cell(row=calculation_row, column=1, value="批次生产日期: 2024-12-19")
        worksheet.cell(row=calculation_row, column=1).font = Font(bold=True)
        worksheet.merge_cells(f'A{calculation_row}:C{calculation_row}')

        calculation_row += 1
        worksheet.cell(row=calculation_row, column=1, value="预测量计算窗口: 2024-09-20 至 2025-01-18")
        worksheet.merge_cells(f'A{calculation_row}:C{calculation_row}')

        calculation_row += 1
        worksheet.cell(row=calculation_row, column=1,
                       value="计算月份: 2024-10, 2024-11, 2024-12, 2025-01（黄色背景标记）")
        worksheet.merge_cells(f'A{calculation_row}:C{calculation_row}')

        calculation_row += 1
        worksheet.cell(row=calculation_row, column=1, value="预测总量计算: 115 + 110 + 80 + 0 = 305件")
        worksheet.merge_cells(f'A{calculation_row}:C{calculation_row}')
        worksheet.cell(row=calculation_row, column=1).font = Font(bold=True, color="FF0000")

        # 添加实际销量数据
        calculation_row += 2
        worksheet.cell(row=calculation_row, column=1, value="实际销量窗口: 2024-12-19 至 今天")
        worksheet.merge_cells(f'A{calculation_row}:C{calculation_row}')

        calculation_row += 1
        worksheet.cell(row=calculation_row, column=1, value="李根在此期间的F01H2A实际销量: 13件")
        worksheet.merge_cells(f'A{calculation_row}:C{calculation_row}')
        worksheet.cell(row=calculation_row, column=1).font = Font(bold=True, color="FF0000")

        # 添加履行率计算
        calculation_row += 2
        worksheet.cell(row=calculation_row, column=1, value="履行率计算: 13 ÷ 305 × 100% = 4.3%")
        worksheet.merge_cells(f'A{calculation_row}:C{calculation_row}')
        worksheet.cell(row=calculation_row, column=1).font = Font(bold=True)

        # 添加责任得分计算
        calculation_row += 2
        worksheet.cell(row=calculation_row, column=1, value="责任得分计算:")
        worksheet.merge_cells(f'A{calculation_row}:C{calculation_row}')
        worksheet.cell(row=calculation_row, column=1).font = Font(bold=True)

        calculation_row += 1
        worksheet.cell(row=calculation_row, column=1, value="• 预测占比: 305 ÷ 总预测量(1150) = 26.5%")
        worksheet.merge_cells(f'A{calculation_row}:C{calculation_row}')

        calculation_row += 1
        worksheet.cell(row=calculation_row, column=1, value="• 调整因子: 0.5 + 0.5 × 26.5% = 0.6325")
        worksheet.merge_cells(f'A{calculation_row}:C{calculation_row}')

        calculation_row += 1
        worksheet.cell(row=calculation_row, column=1, value="• 预测销售差异得分: 60% × (1 - 4.3%) × 2 × 0.6325 ≈ 0.73")
        worksheet.merge_cells(f'A{calculation_row}:C{calculation_row}')
        worksheet.cell(row=calculation_row, column=1).font = Font(bold=True, color="FF0000")

        # 添加结论
        calculation_row += 2
        worksheet.cell(row=calculation_row, column=1,
                       value="结论: 李根的预测量(305件)与实际销量(13件)差异很大，履行率极低(4.3%)，因此获得较高的责任得分。")
        worksheet.merge_cells(f'A{calculation_row}:I{calculation_row}')
        worksheet.cell(row=calculation_row, column=1).font = Font(bold=True)
        worksheet.cell(row=calculation_row, column=1).fill = PatternFill(start_color="FCE4D6", end_color="FCE4D6",
                                                                         fill_type="solid")

        # 设置列宽
        worksheet.column_dimensions['A'].width = 20
        worksheet.column_dimensions['B'].width = 15
        worksheet.column_dimensions['C'].width = 15

        return calculation_row + 2  # 返回结束行号

    def add_responsibility_logic_sheet(self, worksheet):
        """
        创建责任判定逻辑说明工作表，详细解释责任判定的计算逻辑
        增加预测量和实际销量的计算窗口和方法说明
        """
        # 标题
        worksheet.cell(row=1, column=1, value="库存积压预警系统责任判定逻辑详解")
        worksheet.cell(row=1, column=1).font = Font(bold=True, size=16)
        worksheet.merge_cells('A1:F1')

        # 添加说明内容
        content = [
            # 1. 总体介绍
            ("一、责任判定总体框架", "", 16, True),
            ("",
             "本系统采用\"谁预测谁负责\"为核心原则，通过三个维度综合评估责任：预测与实际销售差异(60%)、销售响应及时性(25%)和订单历史关联度(15%)。",
             12, False),
            ("",
             "库存责任优先按预测未兑现量(预测量-实际销量)分配，确保责任分配准确、公平和可解释。主要责任人为应承担库存数量最多的人，而非责任得分最高的人。",
             12, False),

            # 新增：预测量和实际销量计算窗口和方法说明
            ("1.5、预测量与实际销量计算方法", "", 14, True),
            ("预测量计算窗口",
             "系统会查找批次生产日期前90天到批次生产日期后30天这个时间范围内的预测记录。例如，批次生产日期是2024-12-19，预测窗口为2024-09-20至2025-01-18。",
             12, True),
            ("",
             "由于系统按完整月份计算，因此会计算窗口期内的所有完整月份的预测量之和。在上述例子中，将计算2024-10、2024-11、2024-12和2025-01这四个月的预测量总和。",
             12, False),
            ("实际销量计算窗口",
             "系统会查找批次生产日期到今天(或批次生产日期后90天，取较小值)这个时间窗口内的所有实际出货记录。例如，批次生产日期是2024-12-19，销量窗口为2024-12-19至今。",
             12, True),
            ("",
             "系统会计算窗口期内指定销售人员的所有该产品出货记录总和，作为实际销量。如果没有出货记录，则实际销量为0。",
             12, False),
            ("未兑现预测量",
             "未兑现预测量 = max(0, 预测量-实际销量)，表示销售员预测但未能实现的销量。这是库存责任分配的核心指标。",
             12, True),
            ("具体示例",
             "以物料F01H2A、销售员李根、批次日期2024-12-19为例：\n"
             "• 预测窗口：2024-09-20至2025-01-18\n"
             "• 包含月份：2024-10月(115件)、2024-11月(110件)、2024-12月(80件)、2025-01月(0件)\n"
             "• 预测总量：115 + 110 + 80 + 0 = 305件\n"
             "• 实际窗口：2024-12-19至今\n"
             "• 实际销量：李根在此期间出货13件\n"
             "• 未兑现预测量：305 - 13 = 292件",
             12, True),

            # 2. 预测销售差异
            ("二、预测与实际销售差异分析 (权重60%)", "", 14, True),
            ("计算逻辑：", "", 12, True),
            ("", "• 系统比较每个销售人员提交的预测销量与后续实际发生的销售量", 12, False),
            ("", "• 关键指标：未兑现预测量 = max(0, 预测量 - 实际销量)", 12, False),
            ("", "• 未兑现预测量越高，责任越大", 12, False),
            ("详细计分规则：", "", 12, True),
            ("", "• 履行率 = 实际销量 / 预测量", 12, False),
            ("", "• 销售不到预测的50%：责任得分 = 60% × (1-履行率) × 2", 12, False),
            ("", "• 销售不到预测的80%：责任得分 = 60% × (1-履行率) × 1.5", 12, False),
            ("", "• 销售基本符合预测：责任得分 = 60% × (1-履行率) × 0.5", 12, False),
            ("", "• 预测量因素：预测占比越大，责任得分越高", 12, False),
            ("举例说明：", "", 12, True),
            ("", "销售A预测某产品销量100件，实际销售40件", 12, False),
            ("", "• 未兑现预测量 = 100 - 40 = 60件", 12, False),
            ("", "• 履行率 = 40%", 12, False),
            ("", "• 基础得分 = 60% × (1-40%) × 2 = 0.72", 12, False),
            ("", "• 预测占比调整后得分 = 0.72 × (0.5 + 0.5 × 80%) = 0.648", 12, False),

            # 3. 销售响应及时性
            ("三、销售响应及时性分析 (权重25%)", "", 14, True),
            ("计算逻辑：", "", 12, True),
            ("", "• 系统计算从批次生产到首次销售的响应天数", 12, False),
            ("", "• 响应越慢，责任得分越高", 12, False),
            ("详细计分规则：", "", 12, True),
            ("", "• 45天以上才有首次销售：得分 = 25% × 1.0", 12, False),
            ("", "• 30-45天有首次销售：得分 = 25% × 0.8", 12, False),
            ("", "• 15-30天有首次销售：得分 = 25% × 0.5", 12, False),
            ("", "• 15天内有销售响应：得分 = 25% × 0.2", 12, False),
            ("举例说明：", "", 12, True),
            ("", "批次生产后，销售A在38天后才有首次销售", 12, False),
            ("", "• 响应及时性得分 = 25% × 0.8 = 0.2", 12, False),

            # 4. 订单历史关联度
            ("四、订单历史与批次产生关联度 (权重15%)", "", 14, True),
            ("计算逻辑：", "", 12, True),
            ("", "• 系统分析批次生产前60天内的订单记录", 12, False),
            ("", "• 订单占比越高，责任得分越高", 12, False),
            ("", "• 得分 = 15% × 订单占比", 12, False),
            ("举例说明：", "", 12, True),
            ("", "批次生产前，销售A的订单量占总订单量的30%", 12, False),
            ("", "• 订单关联度得分 = 15% × 30% = 0.045", 12, False),

            # 5. 责任共担机制 - 修改为优先按预测未兑现量分配
            ("五、库存责任分配机制", "", 14, True),
            ("计算逻辑：", "", 12, True),
            ("", "• 第一步：计算每个人的\"未兑现预测量\" = max(0, 预测量 - 实际销量)", 12, False),
            ("", "• 第二步：主要按未兑现预测量比例分配库存，体现\"谁预测谁负责\"原则", 12, False),
            ("", "• 第三步：应承担库存数量最多的人为主要责任人", 12, False),
            ("", "• 第四步：只有有预测的人员会被分配库存责任", 12, False),
            ("", "• 第五步：系统管理员作为责任人时，对应区域为空", 12, False),
            ("举例说明：", "", 12, True),
            ("", "• 谢剑峰：预测90件，实际销量15件，未兑现75件", 12, False),
            ("", "• 孙杨：预测160件，实际销量30件，未兑现130件", 12, False),
            ("", "• 李根：预测145件，实际销量59件，未兑现86件", 12, False),
            ("", "• 未兑现预测总量：75 + 130 + 86 = 291件", 12, False),
            ("", "• 谢剑峰应分配库存：82 × (75 ÷ 291) ≈ 21件", 12, False),
            ("", "• 实际分配可能会因总得分和其他因素略有调整", 12, False),

            # 6. 责任判定目的和改进建议
            ("六、责任判定的目的及改进建议", "", 14, True),
            ("责任判定目的：", "", 12, True),
            ("", "• 明确库存积压问题的主要责任人，提供清晰的改进方向", 12, False),
            ("", "• 促进销售预测准确性的提升和库存积压的减少", 12, False),
            ("", "• 构建分级响应机制，提高库存管理效率", 12, False),
            ("改进建议：", "", 12, True),
            ("", "• 提高预测准确性：重点关注预测偏差大的销售人员，调整预测方法", 12, False),
            ("", "• 提高销售执行力：确保销售人员能够实现自己的预测目标", 12, False),
            ("", "• 加强销售与计划协同：减少预测与实际销售的差异", 12, False),
            ("", "• 定期监控：跟踪每个销售人员的预测准确率和销售履行率", 12, False),

            # 7. 特殊情况处理说明
            ("七、特殊情况处理说明", "", 14, True),
            ("", "• 预测量为0且无销售记录的人员通常不承担库存责任", 12, False),
            ("", "• 对于有预测但预测量极低的人员，设置最低阈值(5%)以确保责任分配合理", 12, False),
            ("", "• 当单一销售人员预测占比超过95%时，该人员承担全部库存责任", 12, False),
            ("", "• 系统管理员作为责任人时，其对应区域始终为空", 12, False),
            ("", "• 季节性产品会考虑季节因素影响，调整责任判定", 12, False),
        ]

        # 写入内容
        row_idx = 3
        for text, detail, font_size, is_bold in content:
            if text:
                cell = worksheet.cell(row=row_idx, column=1, value=text)
                cell.font = Font(size=font_size, bold=is_bold)
                if is_bold and font_size > 12:
                    worksheet.merge_cells(f'A{row_idx}:F{row_idx}')
                    # 为标题添加背景色
                    cell.fill = PatternFill(start_color="E3F2FD", end_color="E3F2FD", fill_type="solid")
                    row_idx += 1

            if detail:
                cell = worksheet.cell(row=row_idx, column=2, value=detail)
                cell.font = Font(size=font_size)
                worksheet.merge_cells(f'B{row_idx}:F{row_idx}')

            row_idx += 1

        # 设置列宽
        worksheet.column_dimensions['A'].width = 30
        worksheet.column_dimensions['B'].width = 15
        worksheet.column_dimensions['C'].width = 15
        worksheet.column_dimensions['D'].width = 15
        worksheet.column_dimensions['E'].width = 15
        worksheet.column_dimensions['F'].width = 15

        # 添加页脚
        footer_row = row_idx + 2
        footer_text = "注：本文档详细解释了库存积压预警系统的责任判定逻辑，目的是帮助销售代表更好地理解责任判定过程，"
        footer_text += "从而有针对性地改进工作。核心原则是\"谁预测谁负责\"，确保责任明确，促进销售预测准确性提升。"
        worksheet.cell(row=footer_row, column=1, value=footer_text)
        worksheet.merge_cells(f'A{footer_row}:F{footer_row}')
        worksheet.cell(row=footer_row, column=1).font = Font(italic=True)

        # 添加指导说明
        guide_row = footer_row + 2
        guide_text = "使用指南：查看具体批次的责任判定详情和计算示例，请参考「责任判定详情」工作表，该表展示了每个批次的具体计算过程和详细案例。"
        worksheet.cell(row=guide_row, column=1, value=guide_text)
        worksheet.merge_cells(f'A{guide_row}:F{guide_row}')
        worksheet.cell(row=guide_row, column=1).font = Font(bold=True, color="0000FF")

        print("责任判定逻辑说明工作表已创建，增加了预测量和实际销量计算逻辑的详细解释")

    def add_responsibility_flowchart_sheet(self, worksheet):
        """
        创建责任判定流程图工作表，以图形方式展示责任判定流程
        """
        # 设置标题
        worksheet.cell(row=1, column=1, value="库存积压预警系统责任判定流程图")
        worksheet.cell(row=1, column=1).font = Font(bold=True, size=16)
        worksheet.merge_cells('A1:L1')

        # 添加说明文字
        worksheet.cell(row=3, column=1,
                       value="流程说明：本流程图展示了库存积压系统的责任判定流程，从数据加载到最终责任确定的完整过程。")
        worksheet.merge_cells('A3:L3')

        # 使用单元格绘制流程图（简化方法，适用于Excel）

        # 1. 流程起点
        worksheet.cell(row=5, column=5, value="开始")
        worksheet.cell(row=5, column=5).alignment = Alignment(horizontal='center', vertical='center')
        worksheet.cell(row=5, column=5).fill = PatternFill(start_color="E1F5FE", end_color="E1F5FE", fill_type="solid")
        worksheet.cell(row=5, column=5).border = Border(
            left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin')
        )

        # 2. 数据加载
        worksheet.cell(row=7, column=5, value="数据加载")
        worksheet.cell(row=7, column=5).alignment = Alignment(horizontal='center', vertical='center')
        worksheet.cell(row=7, column=5).fill = PatternFill(start_color="E8F5E9", end_color="E8F5E9", fill_type="solid")
        worksheet.cell(row=7, column=5).border = Border(
            left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin')
        )
        worksheet.cell(row=7, column=6, value="加载库存、出货、预测和价格数据")

        # 3. 建立映射关系
        worksheet.cell(row=9, column=5, value="建立销售人员-区域映射")
        worksheet.cell(row=9, column=5).alignment = Alignment(horizontal='center', vertical='center')
        worksheet.cell(row=9, column=5).fill = PatternFill(start_color="E8F5E9", end_color="E8F5E9", fill_type="solid")
        worksheet.cell(row=9, column=5).border = Border(
            left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin')
        )

        # 4. 批次责任计算
        worksheet.cell(row=11, column=5, value="批次责任计算")
        worksheet.cell(row=11, column=5).alignment = Alignment(horizontal='center', vertical='center')
        worksheet.cell(row=11, column=5).font = Font(bold=True)
        worksheet.cell(row=11, column=5).fill = PatternFill(start_color="FFF9C4", end_color="FFF9C4", fill_type="solid")
        worksheet.cell(row=11, column=5).border = Border(
            left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin')
        )
        worksheet.merge_cells('E11:G11')

        # 5. 三个责任维度
        # 5.1 预测销售差异
        worksheet.cell(row=13, column=3, value="预测销售差异(60%权重)")
        worksheet.cell(row=13, column=3).alignment = Alignment(horizontal='center', vertical='center')
        worksheet.cell(row=13, column=3).fill = PatternFill(start_color="FFECB3", end_color="FFECB3", fill_type="solid")
        worksheet.cell(row=13, column=3).border = Border(
            left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin')
        )
        worksheet.cell(row=14, column=3, value="计算公式: 60% × (1-履行率) × 权重")
        worksheet.cell(row=14, column=3).font = Font(size=9)

        # 5.2 销售响应及时性
        worksheet.cell(row=13, column=5, value="销售响应及时性(25%权重)")
        worksheet.cell(row=13, column=5).alignment = Alignment(horizontal='center', vertical='center')
        worksheet.cell(row=13, column=5).fill = PatternFill(start_color="FFECB3", end_color="FFECB3", fill_type="solid")
        worksheet.cell(row=13, column=5).border = Border(
            left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin')
        )
        worksheet.cell(row=14, column=5, value="计算响应天数对应的权重分数")
        worksheet.cell(row=14, column=5).font = Font(size=9)

        # 5.3 订单历史关联度
        worksheet.cell(row=13, column=7, value="订单历史关联度(15%权重)")
        worksheet.cell(row=13, column=7).alignment = Alignment(horizontal='center', vertical='center')
        worksheet.cell(row=13, column=7).fill = PatternFill(start_color="FFECB3", end_color="FFECB3", fill_type="solid")
        worksheet.cell(row=13, column=7).border = Border(
            left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin')
        )
        worksheet.cell(row=14, column=7, value="计算公式: 15% × 订单占比")
        worksheet.cell(row=14, column=7).font = Font(size=9)

        # 6. 责任得分汇总
        worksheet.cell(row=16, column=5, value="责任得分汇总")
        worksheet.cell(row=16, column=5).alignment = Alignment(horizontal='center', vertical='center')
        worksheet.cell(row=16, column=5).fill = PatternFill(start_color="E1F5FE", end_color="E1F5FE", fill_type="solid")
        worksheet.cell(row=16, column=5).border = Border(
            left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin')
        )
        worksheet.cell(row=17, column=5, value="总得分 = 预测差异得分 + 响应及时性得分 + 订单关联度得分")
        worksheet.cell(row=17, column=5).font = Font(size=9)

        # 7. 责任共担机制
        worksheet.cell(row=19, column=5, value="库存责任分配机制")
        worksheet.cell(row=19, column=5).alignment = Alignment(horizontal='center', vertical='center')
        worksheet.cell(row=19, column=5).font = Font(bold=True)
        worksheet.cell(row=19, column=5).fill = PatternFill(start_color="E8F5E9", end_color="E8F5E9", fill_type="solid")
        worksheet.cell(row=19, column=5).border = Border(
            left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin')
        )
        worksheet.merge_cells('E19:G19')
        # 修改：强调应承担库存数量
        worksheet.cell(row=20, column=5, value="库存仅分配给有预测未兑现的人员，应承担库存数量最多的人为主要责任人")
        worksheet.merge_cells('E20:G20')

        # 8. 输出责任分析结果
        worksheet.cell(row=22, column=5, value="输出责任分析结果")
        worksheet.cell(row=22, column=5).alignment = Alignment(horizontal='center', vertical='center')
        worksheet.cell(row=22, column=5).fill = PatternFill(start_color="E1F5FE", end_color="E1F5FE", fill_type="solid")
        worksheet.cell(row=22, column=5).border = Border(
            left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin')
        )

        # 9. 结束
        worksheet.cell(row=24, column=5, value="结束")
        worksheet.cell(row=24, column=5).alignment = Alignment(horizontal='center', vertical='center')
        worksheet.cell(row=24, column=5).fill = PatternFill(start_color="E1F5FE", end_color="E1F5FE", fill_type="solid")
        worksheet.cell(row=24, column=5).border = Border(
            left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin')
        )

        # 添加连接线(使用｜和－字符模拟连接线)
        # 垂直连接线
        for row in [6, 8, 10, 12, 15, 18, 21, 23]:
            worksheet.cell(row=row, column=5, value="|")
            worksheet.cell(row=row, column=5).alignment = Alignment(horizontal='center', vertical='center')

        # 从批次责任计算到三个维度的连接线
        worksheet.cell(row=12, column=3, value="<---")
        worksheet.cell(row=12, column=3).alignment = Alignment(horizontal='center', vertical='center')
        worksheet.cell(row=12, column=7, value="--->")
        worksheet.cell(row=12, column=7).alignment = Alignment(horizontal='center', vertical='center')

        # 从三个维度到得分汇总的连接线
        worksheet.cell(row=15, column=3, value="|")
        worksheet.cell(row=15, column=3).alignment = Alignment(horizontal='center', vertical='center')
        worksheet.cell(row=15, column=7, value="|")
        worksheet.cell(row=15, column=7).alignment = Alignment(horizontal='center', vertical='center')

        # 添加详细说明区域
        worksheet.cell(row=5, column=9, value="详细说明")
        worksheet.cell(row=5, column=9).font = Font(bold=True)
        worksheet.merge_cells('I5:L5')

        explanations = [
            "1. 数据加载：系统加载库存、出货、预测和价格数据，作为责任分析的基础。",
            "2. 建立映射：确定销售人员与区域的对应关系，确保责任人与区域匹配。系统管理员对应区域为空。",
            "3. 预测销售差异分析：计算预测销量与实际销量的差异，权重60%。",
            "   - 履行率 = 实际销售量 / 预测销量",
            "   - 履行率越低，责任得分越高",
            "4. 销售响应及时性分析：计算从批次生产到首次销售的响应时间，权重25%。",
            "   - 响应越慢，责任得分越高",
            "5. 订单历史关联度分析：分析批次生产前的订单记录，权重15%。",
            "   - 订单占比越高，责任得分越高",
            "6. 责任得分汇总：计算每个销售人员的总责任得分。",
            "7. 责任共担机制：确定主要责任人和共同责任人。",
            "   - 应承担库存数量最多的销售人员为主要责任人",
            "   - 有预测未兑现量的人员为共同责任人",
            "   - 按库存分配量降序显示责任人"
        ]

        for i, explanation in enumerate(explanations):
            worksheet.cell(row=6 + i, column=9, value=explanation)
            worksheet.merge_cells(f'I{6 + i}:L{6 + i}')

        # 设置列宽
        for col in range(1, 13):
            col_letter = get_column_letter(col)
            if col in [3, 5, 7]:  # 主要流程图列
                worksheet.column_dimensions[col_letter].width = 25
            elif col >= 9:  # 说明列
                worksheet.column_dimensions[col_letter].width = 15
            else:  # 间隔列
                worksheet.column_dimensions[col_letter].width = 5

        # 添加页脚说明
        footer_row = 26
        worksheet.cell(row=footer_row, column=1,
                       value="备注：本流程图简化展示了责任判定的主要过程，详细计算逻辑请参考「责任判定逻辑说明」工作表。")
        worksheet.merge_cells(f'A{footer_row}:L{footer_row}')
        worksheet.cell(row=footer_row, column=1).font = Font(italic=True)

        print("责任判定流程图工作表已创建")

    def generate_visualization(self, timestamp):
        """优化的可视化图表生成函数 - 添加专业性的分析和洞察"""
        import matplotlib.font_manager as fm
        import matplotlib as mpl

        # 配置matplotlib以正确显示中文
        print("正在配置中文字体支持...")

        # 方法1: 尝试使用系统中的中文字体
        chinese_fonts = []

        # Windows系统中文字体
        windows_fonts = ['Microsoft YaHei', 'SimHei', 'SimSun', 'NSimSun', 'FangSong', 'KaiTi']
        # macOS系统中文字体
        macos_fonts = ['PingFang SC', 'STHeiti', 'Heiti SC', 'Heiti TC', 'PingFang TC']
        # Linux系统中文字体
        linux_fonts = ['WenQuanYi Micro Hei', 'WenQuanYi Zen Hei', 'Droid Sans Fallback']

        # 合并所有可能的字体
        all_fonts = windows_fonts + macos_fonts + linux_fonts

        # 检查系统中是否有这些字体
        system_fonts = [f.name for f in fm.fontManager.ttflist]
        for font in all_fonts:
            if any(font.lower() in f.lower() for f in system_fonts):
                chinese_fonts.append(font)
                print(f"找到中文字体: {font}")

        # 设置找到的第一个可用中文字体
        if chinese_fonts:
            plt.rcParams['font.family'] = chinese_fonts[0]
            plt.rcParams['axes.unicode_minus'] = False  # 解决负号显示问题
            print(f"使用中文字体: {chinese_fonts[0]}")
        else:
            # 如果没有找到中文字体，尝试使用matplotlib内置的字体
            plt.rcParams['font.sans-serif'] = ['DejaVu Sans', 'Arial Unicode MS', 'sans-serif']
            plt.rcParams['axes.unicode_minus'] = False
            print("未找到系统中文字体，使用默认字体")

        # 设置绘图风格
        try:
            # 尝试设置样式
            plt.style.use('ggplot')
        except:
            print("警告: 无法设置图表样式，使用默认样式")

        # 新增：为每个图表创建解释文本
        visualizations_explained = {}

        # 1.风险分布饼图
        print("生成风险分布饼图...")
        risk_counts = self.batch_analysis['风险程度'].value_counts()

        plt.figure(figsize=(12, 8))
        colors = ['#8B0000', '#FF0000', '#FFA500', '#4CAF50', '#2196F3']  # 从深红到蓝
        explode = [0.1 if x == '极高风险' else 0.05 if x == '高风险' else 0 for x in risk_counts.index]

        # 绘制饼图
        wedges, texts = plt.pie(
            risk_counts,
            labels=None,  # 移除直接标签，避免遮挡
            autopct=None,  # 移除百分比标签，避免遮挡
            colors=colors,
            startangle=90,
            explode=explode,
            shadow=True,
            wedgeprops={'edgecolor': 'w', 'linewidth': 1}
        )

        # 添加更清晰的图例，替代直接标签
        plt.legend(
            wedges,
            [f"{label} ({count}批次, {count / sum(risk_counts.values) * 100:.1f}%)"
             for label, count in zip(risk_counts.index, risk_counts.values)],
            title="风险等级",
            loc="center left",
            bbox_to_anchor=(1, 0, 0.5, 1)
        )

        title = '库存批次积压风险分布分析图'
        plt.title(title, fontsize=16, fontweight='bold', pad=20)

        # 添加专业化的分析说明文字
        # 修改后的代码
        plt.figtext(0.5, 0.01,
                    "本图展示了所有库存批次按风险等级的分布情况。\n"
                    "极高风险和高风险批次需要优先处理，以减少库存积压成本和资金占用。\n"
                    f"目前有{risk_counts.get('极高风险', 0) + risk_counts.get('高风险', 0)}个批次需要紧急处理。",
                    ha="center", fontsize=12, bbox={"facecolor": "aliceblue", "alpha": 0.5, "pad": 5})

        plt.tight_layout()
        try:
            pie_chart_path = os.path.join(self.output_folder, f'风险分布_{timestamp}.png')
            plt.savefig(pie_chart_path, dpi=300, bbox_inches='tight')
            print(f"饼图已保存至: {pie_chart_path}")
        except Exception as e:
            print(f"保存饼图时出错: {str(e)}，尝试保存到当前目录")
            pie_chart_path = os.path.join(os.getcwd(), f'风险分布_{timestamp}.png')
            plt.savefig(pie_chart_path, dpi=300, bbox_inches='tight')
            print(f"饼图已保存至当前目录: {pie_chart_path}")

        plt.close()

        # 保存图表解释，提供更专业的分析洞察
        risk_distribution = {risk: count / sum(risk_counts.values) * 100 for risk, count in risk_counts.items()}
        critical_insight = ""
        if risk_distribution.get('极高风险', 0) > 15:
            critical_insight = "极高风险批次占比超过15%，表明库存结构存在严重问题，需要紧急干预。"
        elif (risk_distribution.get('极高风险', 0) + risk_distribution.get('高风险', 0)) > 30:
            critical_insight = "高风险类批次总占比超过30%，库存结构不健康，需要系统性改进库存管理流程。"
        else:
            critical_insight = "高风险批次比例相对可控，建议关注个别重点批次并优化预测准确性。"

        visualizations_explained["库存风险分布分析"] = {
            "文件路径": pie_chart_path,
            "说明": "此图显示了所有库存批次按风险等级(极高、高、中、低、极低)的分布比例。风险评估基于库龄、销量波动、预计清库天数和预测准确性等多维度指标综合计算。通过此图可快速识别库存风险集中度，为库存优化提供方向。",
            "关键发现": f"极高风险批次占比{risk_distribution.get('极高风险', 0):.1f}%，高风险批次占比{risk_distribution.get('高风险', 0):.1f}%。{critical_insight}"
        }

        # 2.高风险批次库龄分布
        print("生成高风险批次库龄分布图...")
        high_risk_batches = self.batch_analysis[self.batch_analysis['风险程度'].isin(['极高风险', '高风险'])]
        if len(high_risk_batches) > 0:
            # 排序批次数据，按库龄降序
            high_risk_batches = high_risk_batches.sort_values('库龄', ascending=False)

            # 创建图形，动态调整大小以适应数据量
            plt.figure(figsize=(14, max(8, len(high_risk_batches[:10]) * 0.6)))

            # 只显示前10个批次，避免图表过于拥挤
            top_batches = high_risk_batches.head(10)

            # 创建批次标签 - 更加清晰的格式
            batch_labels = [f"{code} ({date})" for code, date in
                            zip(top_batches['物料'], top_batches['批次日期'].astype(str))]

            # 设置颜色 - 使用风险程度区分
            bar_colors = ['#8B0000' if x == '极高风险' else '#FF5252' for x in top_batches['风险程度']]

            # 绘制水平条形图
            bars = plt.barh(
                batch_labels,
                top_batches['库龄'],
                color=bar_colors,
                height=0.6,
                alpha=0.8
            )

            # 添加数据标签 - 显示库龄天数
            for bar in bars:
                width = bar.get_width()
                label_x = width + 5
                label_y = bar.get_y() + bar.get_height() / 2
                label_text = f'{int(width)}天'
                plt.text(label_x, label_y, label_text, va='center', ha='left', fontweight='bold')

            # 添加风险阈值参考线
            plt.axvline(x=90, color='red', linestyle='--', label='高风险阈值 (90天)', alpha=0.7)
            plt.axvline(x=60, color='orange', linestyle='--', label='中风险阈值 (60天)', alpha=0.7)
            plt.axvline(x=30, color='green', linestyle='--', label='低风险阈值 (30天)', alpha=0.7)

            # 设置标题和标签
            title = '高风险批次库龄分布分析'
            plt.title(title, fontsize=16, fontweight='bold', pad=20)
            plt.xlabel('库龄（天）', fontsize=12)

            # 添加图例 - 位置调整避免遮挡
            plt.legend(loc='upper right', bbox_to_anchor=(1, 1))

            # 添加网格线以提高可读性
            plt.grid(True, axis='x', alpha=0.3, linestyle='--')

            # 添加专业分析文字
            avg_age = top_batches['库龄'].mean()
            max_age_batch = top_batches.iloc[0]
            plt.figtext(0.5, 0.01,
                        f"本图显示了高风险批次的库龄分布，平均库龄为{avg_age:.1f}天。\n"
                        f"最高库龄批次为{max_age_batch['物料']}，已存放{max_age_batch['库龄']}天，"
                        f"批次价值{max_age_batch['批次价值']:,.2f}元。\n"
                        "长期呆滞批次占用仓储空间并增加资金成本，建议优先处理库龄超过90天的批次。",
                        ha="center", fontsize=12, bbox={"facecolor": "aliceblue", "alpha": 0.5, "pad": 5})

            plt.tight_layout(rect=[0, 0.08, 1, 0.97])  # 给底部文字留出空间
            try:
                high_risk_path = os.path.join(self.output_folder, f'高风险批次库龄_{timestamp}.png')
                plt.savefig(high_risk_path, dpi=300, bbox_inches='tight')
                print(f"高风险批次库龄分布图已保存至: {high_risk_path}")
            except Exception as e:
                print(f"保存图表出错: {str(e)}，尝试保存到当前目录")
                high_risk_path = os.path.join(os.getcwd(), f'高风险批次库龄_{timestamp}.png')
                plt.savefig(high_risk_path, dpi=300, bbox_inches='tight')
                print(f"高风险批次库龄分布图已保存至当前目录: {high_risk_path}")

            plt.close()

            # 保存图表解释与专业洞察
            above_90_days = sum(top_batches['库龄'] > 90)
            oldest_batch = top_batches.iloc[0]
            visualizations_explained["高风险批次库龄分析"] = {
                "文件路径": high_risk_path,
                "说明": "此图分析展示了高风险批次的库龄分布情况，库龄是评估库存健康度的关键指标之一。图中横线标记表示三个风险阈值：90天(高风险)、60天(中风险)和30天(低风险)。深红色表示极高风险批次，红色表示高风险批次。",
                "关键发现": f"分析显示有{above_90_days}个批次库龄超过90天高风险阈值，最老批次{oldest_batch['物料']}已存放{oldest_batch['库龄']}天，价值{oldest_batch['批次价值']:,.2f}元。库龄分布偏高表明库存周转效率不足，长期呆滞批次占用资金成本约为{sum(top_batches['批次价值']) * 0.12 / 365 * avg_age:,.2f}元（按年化12%资金成本计算）。"
            }
        else:
            print("没有高风险批次，跳过生成高风险批次库龄分布图")

        # 3. 改进预测偏差图 - 更多专业洞察
        print("生成改进的预测偏差分析图...")

        # 筛选出高风险批次的预测偏差数据
        high_risk_forecast = high_risk_batches.copy() if len(high_risk_batches) > 0 else self.batch_analysis.head(10)

        # 转换预测偏差为数值
        high_risk_forecast['预测偏差数值'] = high_risk_forecast['预测偏差'].apply(
            lambda x: float(str(x).rstrip('%')) / 100 if isinstance(x, str) and '%' in x else 0
        )

        # 按偏差绝对值排序，显示最大的8个偏差，避免图表过于拥挤
        high_risk_forecast = high_risk_forecast.reindex(
            high_risk_forecast['预测偏差数值'].abs().sort_values(ascending=False).index
        ).head(8)

        # 创建更大的图形
        plt.figure(figsize=(14, 10))

        # 准备数据，确保标签简短清晰
        products = []
        for code, desc in zip(high_risk_forecast['物料'], high_risk_forecast['描述']):
            short_desc = desc[:20] + '...' if len(desc) > 20 else desc
            products.append(f"{code}: {short_desc}")

        biases = high_risk_forecast['预测偏差数值'].tolist()

        # 创建颜色映射 - 正偏差(预测过高)为红色，负偏差(预测过低)为蓝色
        colors = ['#FF5252' if x > 0 else '#4682B4' for x in biases]

        # 创建水平条形图
        bars = plt.barh(products, [abs(b) * 100 for b in biases], color=colors, alpha=0.8)

        # 添加更清晰的数据标签
        for i, bar in enumerate(bars):
            width = bar.get_width()
            label_x = width + 2
            label_y = bar.get_y() + bar.get_height() / 2
            direction = "预测过高" if biases[i] > 0 else "预测过低"
            label_text = f'{abs(biases[i]) * 100:.1f}% ({direction})'
            plt.text(label_x, label_y, label_text, va='center', ha='left', fontweight='bold')

        # 设置图表标题和标签
        plt.title('批次预测偏差分析', fontsize=16, fontweight='bold', pad=20)
        plt.xlabel('预测偏差百分比（绝对值）', fontsize=12)
        plt.ylabel('产品代码', fontsize=12)

        # 设置X轴范围，确保所有标签可见
        plt.xlim(0, min(max([abs(b) * 100 for b in biases]) * 1.2, 100))

        # 添加图例
        from matplotlib.patches import Patch
        legend_elements = [
            Patch(facecolor='#FF5252', label='预测过高 - 导致库存积压'),
            Patch(facecolor='#4682B4', label='预测过低 - 可能导致缺货')
        ]
        plt.legend(handles=legend_elements, loc='upper right')

        # 添加网格线
        plt.grid(True, axis='x', alpha=0.3, linestyle='--')

        # 添加专业的分析说明文字
        over_prediction = sum(1 for b in biases if b > 0)
        under_prediction = sum(1 for b in biases if b < 0)
        plt.figtext(0.5, 0.01,
                    f"本图显示了预测偏差最显著的{len(biases)}个批次，其中{over_prediction}个是预测过高，{under_prediction}个是预测过低。\n"
                    f"预测过高会导致库存积压和资金占用，预测过低则可能导致缺货和销售损失。\n"
                    f"平均预测偏差为{sum(abs(b) for b in biases) / len(biases) * 100:.1f}%，表明预测系统准确度有明显提升空间。",
                    ha="center", fontsize=12, bbox={"facecolor": "aliceblue", "alpha": 0.8, "pad": 5})

        plt.tight_layout(rect=[0, 0.08, 1, 0.95])

        # 保存图表
        try:
            forecast_bias_path = os.path.join(self.output_folder, f'预测偏差分析_{timestamp}.png')
            plt.savefig(forecast_bias_path, dpi=300, bbox_inches='tight')
            print(f"预测偏差分析图已保存至: {forecast_bias_path}")
        except Exception as e:
            print(f"保存图表出错: {str(e)}，尝试保存到当前目录")
            forecast_bias_path = os.path.join(os.getcwd(), f'预测偏差分析_{timestamp}.png')
            plt.savefig(forecast_bias_path, dpi=300, bbox_inches='tight')
            print(f"预测偏差分析图已保存至当前目录: {forecast_bias_path}")

        plt.close()

        # 添加更专业的分析洞察
        worst_overpredict = max(biases) if any(b > 0 for b in biases) else 0
        worst_underpredict = min(biases) if any(b < 0 for b in biases) else 0
        avg_abs_bias = sum(abs(b) for b in biases) / len(biases)

        visualizations_explained["预测偏差分析"] = {
            "文件路径": forecast_bias_path,
            "说明": "此图分析了预测准确性对库存积压的影响。红色表示预测过高(实际销量低于预测)，导致不必要的库存积压；蓝色表示预测过低(实际销量高于预测)，可能导致缺货和销售机会损失。图表按偏差绝对值大小排序，展示偏差最显著的批次。",
            "关键发现": f"预测系统总体偏差为{avg_abs_bias * 100:.1f}%，表明预测准确度中等。{over_prediction}个批次预测过高(最大偏差{worst_overpredict * 100:.1f}%)，{under_prediction}个批次预测过低(最大偏差{abs(worst_underpredict) * 100:.1f}%)。预测偏差主要集中在{over_prediction > under_prediction and '高估需求' or '低估需求'}方向，建议对预测算法进行{over_prediction > under_prediction and '下调校准' or '上调优化'}，并增强对市场波动的敏感度。"
        }

        # 4. 责任分析图 - 保持不变，但添加更多专业洞察

        # 5. 创建改进的清库预测图
        clearance_path = self.generate_improved_clearance_chart(high_risk_batches, timestamp)

        if clearance_path:
            # 添加专业洞察
            avg_clearance = high_risk_batches['预计清库天数'].replace(float('inf'), 365).mean()
            infinite_count = sum(high_risk_batches['预计清库天数'] == float('inf'))

            visualizations_explained["清库预测分析"] = {
                "文件路径": clearance_path,
                "说明": "此图对比展示了高风险批次的预计清库天数(红色)和当前库龄(蓝色)。预计清库天数基于当前日均销量计算，表示在当前销售速度下消化完该批次库存所需的时间。垂直红线表示90天高风险阈值。",
                "关键发现": f"分析显示高风险批次平均清库时间约{avg_clearance:.1f}天，远超90天风险阈值。有{infinite_count}个批次因无销量导致清库天数为无穷大，这类批次需要特别干预措施。库存处理优先级应是：无销量批次 > 清库天数超过180天批次 > 其余高风险批次。建议采取促销、转仓、调配或特价处理等措施加速库存周转。"
        }

            # 创建增强的可视化分析报告
            analysis_report_path = self.create_enhanced_visualization_summary(visualizations_explained, timestamp)

            print(f"可视化图表已生成到文件夹: {self.output_folder}")
            print(f"增强分析报告已保存至: {analysis_report_path}")
            return True

    def generate_improved_clearance_chart(self, high_risk_batches, timestamp):
        """改进的清库预测图表生成函数，提供更专业的可视化"""
        print("生成改进的清库预测图...")

        if len(high_risk_batches) > 0:
            # 按预计清库天数排序
            high_risk_batches = high_risk_batches.copy()
            high_risk_batches['清库天数值'] = high_risk_batches['预计清库天数'].apply(
                lambda x: float('inf') if x == '∞' or x == float('inf') else float(x)
            )

            # 过滤掉无穷大的值，统计无穷大值数量
            finite_batches = high_risk_batches[high_risk_batches['清库天数值'] != float('inf')]
            infinite_batches = high_risk_batches[high_risk_batches['清库天数值'] == float('inf')]

            # 按清库天数排序，只显示TOP 8，避免图表过于拥挤
            sorted_batches = finite_batches.sort_values('清库天数值', ascending=False).head(8)

            # 创建更大的图形以确保足够空间
            plt.figure(figsize=(16, 12))

            # 准备更清晰的数据标签
            products = []
            for code, desc in zip(sorted_batches['物料'], sorted_batches['描述']):
                # 截取产品描述中间的一部分，确保标签短小可读
                short_desc = desc[:20] + '...' if len(desc) > 20 else desc
                products.append(f"{code}: {short_desc}")

            clearance_days = sorted_batches['清库天数值'].tolist()
            ages = sorted_batches['库龄'].tolist()

            # 设置Y轴位置，增加垂直间距
            y_pos = np.arange(len(products)) * 1.5
            width = 0.6

            # 绘制两组条形图
            bars1 = plt.barh(y_pos, clearance_days, height=width, color='#FF5252', label='预计清库天数', alpha=0.8)
            bars2 = plt.barh(y_pos + width, ages, height=width, color='#4682B4', label='当前库龄', alpha=0.8)

            # 添加数据标签，确保显示清晰
            for i, bar in enumerate(bars1):
                width = bar.get_width()
                plt.text(width + 5, y_pos[i], f'{int(width)}天', va='center', fontsize=10, fontweight='bold')

            for i, bar in enumerate(bars2):
                width = bar.get_width()
                plt.text(width + 5, y_pos[i] + 0.6, f'{int(width)}天', va='center', fontsize=10, fontweight='bold')

            # 设置Y轴标签，确保清晰可见
            plt.yticks(y_pos + width / 2, products, fontsize=11)

            # 添加更专业的标题和标签
            plt.title('高风险批次清库预测分析', fontsize=18, fontweight='bold', pad=20)
            plt.xlabel('天数', fontsize=14, fontweight='bold')

            # 设置X轴范围，确保所有数据可见
            plt.xlim(0, max(max(clearance_days), max(ages)) * 1.1)

            # 添加图例，位置设置为最佳位置
            plt.legend(loc='best', fontsize=12)

            # 添加风险阈值参考线
            plt.axvline(x=90, color='red', linestyle='--', label='高风险阈值 (90天)', alpha=0.7, linewidth=2)
            plt.axvline(x=60, color='orange', linestyle='--', label='中风险阈值 (60天)', alpha=0.7, linewidth=1.5)
            plt.axvline(x=30, color='green', linestyle='--', label='低风险阈值 (30天)', alpha=0.7, linewidth=1.5)

            # 增加网格线提高可读性
            plt.grid(True, axis='x', alpha=0.3, linestyle='--')

            # 添加专业的分析说明
            analysis_text = ""
            if clearance_days:
                avg_clearance = sum(clearance_days) / len(clearance_days)
                max_clearance_product = products[clearance_days.index(max(clearance_days))]
                avg_age = sum(ages) / len(ages)

                analysis_text = (
                    f"关键发现：\n"
                    f"• 平均清库时间: {avg_clearance:.1f}天，平均库龄: {avg_age:.1f}天\n"
                    f"• 最长清库时间产品: {max_clearance_product} ({max(clearance_days):.1f}天)\n"
                    f"• {sum(1 for d in clearance_days if d > 90)}个批次清库时间超过90天高风险阈值\n"
                    f"• {len(infinite_batches)}个批次因无销量导致清库时间为无穷大"
                )

            plt.figtext(0.5, 0.02, analysis_text, ha="center", fontsize=12,
                        bbox={"facecolor": "aliceblue", "alpha": 0.8, "pad": 10, "boxstyle": "round,pad=0.5"})

            plt.tight_layout(rect=[0, 0.07, 1, 0.97])  # 调整布局，为底部分析文字留出空间

            try:
                clearance_path = os.path.join(self.output_folder, f'清库预测分析_{timestamp}.png')
                plt.savefig(clearance_path, dpi=300, bbox_inches='tight')
                print(f"改进的清库预测图已保存至: {clearance_path}")
                return clearance_path
            except Exception as e:
                print(f"保存图表出错: {str(e)}，尝试保存到当前目录")
                clearance_path = os.path.join(os.getcwd(), f'清库预测分析_{timestamp}.png')
                plt.savefig(clearance_path, dpi=300, bbox_inches='tight')
                print(f"清库预测图已保存至当前目录: {clearance_path}")
                return clearance_path
        else:
            print("没有高风险批次，跳过生成清库预测图")
            return None

    def create_enhanced_visualization_summary(self, visualizations_explained, timestamp):
        """创建增强的可视化汇总报告，包含更专业的分析和洞察"""
        summary_path = os.path.join(self.output_folder, f'库存风险分析洞察报告_{timestamp}.pdf')
        text_summary_path = os.path.join(self.output_folder, f'库存风险分析洞察报告_{timestamp}.txt')

        try:
            # 首先创建文本版本的报告
            with open(text_summary_path, 'w', encoding='utf-8') as f:
                f.write("=" * 80 + "\n")
                f.write(" 批次级别库存积压预警系统 - 库存风险分析洞察报告\n")
                f.write("=" * 80 + "\n\n")

                f.write(f"生成日期: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")

                f.write("管理摘要\n")
                f.write("-" * 40 + "\n")

                # 计算核心指标
                risk_counts = self.batch_analysis['风险程度'].value_counts()
                high_risk_total = risk_counts.get('极高风险', 0) + risk_counts.get('高风险', 0)
                total_batches = len(self.batch_analysis)
                high_risk_pct = high_risk_total / total_batches * 100 if total_batches > 0 else 0

                # 提取高价值风险批次
                high_value_risk = self.batch_analysis[
                    self.batch_analysis['风险程度'].isin(['极高风险', '高风险'])
                ].sort_values('批次价值', ascending=False)

                total_value = self.batch_analysis['批次价值'].sum()
                high_risk_value = high_value_risk['批次价值'].sum()
                high_risk_value_pct = high_risk_value / total_value * 100 if total_value > 0 else 0

                f.write(
                    f"库存风险概况：分析了{total_batches}个批次，其中{high_risk_total}个({high_risk_pct:.1f}%)为高风险或极高风险。\n")
                f.write(f"这些高风险批次占总库存价值的{high_risk_value_pct:.1f}%，共计¥{high_risk_value:,.2f}元。\n\n")

                f.write("1. 可视化分析洞察\n")
                f.write("-" * 40 + "\n\n")

                # 为每个可视化添加专业化的洞察
                for chart_name, chart_info in visualizations_explained.items():
                    f.write(f"【{chart_name}】\n")
                    f.write(f"位置: {chart_info['文件路径']}\n\n")

                    # 增强的分析说明
                    f.write("分析背景：\n")
                    if "风险分布" in chart_name:
                        f.write("本分析评估了所有库存批次的风险分布情况，使用多维指标对各批次风险进行分级。"
                                "风险评估基于库龄、销量波动、清库难度和预测准确性等因素综合计算。\n\n")
                    elif "库龄分布" in chart_name:
                        f.write("批次库龄是库存健康度的核心指标之一。本图针对高风险批次的库龄分布进行深入分析，"
                                "识别库龄过长的库存积压点，为清库决策提供直观参考。\n\n")
                    elif "预测偏差" in chart_name:
                        f.write("预测准确性对库存管理至关重要。本分析识别出预测偏差最显著的产品批次，"
                                "并区分了预测过高和预测过低两种情况，为改进需求预测流程提供方向。\n\n")
                    elif "责任分析" in chart_name:
                        f.write("库存积压通常涉及多个责任方。本分析从区域和人员两个维度剖析库存责任分布，"
                                "识别关键责任人和责任区域，支持有针对性的改进措施。\n\n")
                    elif "清库预测" in chart_name:
                        f.write("清库周期预测是风险管理的核心环节。本分析基于当前销售趋势，"
                                "对高风险批次的预计清库时间进行模拟，识别需要特殊干预措施的批次。\n\n")

                    # 专业化的洞察分析
                    f.write("关键洞察：\n")
                    f.write(f"{chart_info['关键发现']}\n\n")

                    # 添加专业化的管理建议
                    f.write("管理建议：\n")
                    if "风险分布" in chart_name:
                        f.write("1. 构建分级响应机制，对不同风险等级的批次设置不同的处理流程和优先级\n"
                                "2. 对极高风险批次建立每周监控机制，确保快速响应和处理\n"
                                "3. 制定风险分布月度回顾会议，跟踪风险变化趋势\n\n")
                    elif "库龄分布" in chart_name:
                        f.write("1. 对超过90天库龄的批次实施紧急清库计划，包括促销、转仓或调配\n"
                                "2. 建立库龄梯度预警机制，在批次到达60天前进行提前干预\n"
                                "3. 对长期呆滞库存制定报废或特价处理方案\n\n")
                    elif "预测偏差" in chart_name:
                        f.write("1. 针对预测过高的产品，进行预测算法或参数调整，重点关注季节性因素影响\n"
                                "2. 对销售团队进行预测准确性培训，改进预测方法和流程\n"
                                "3. 实施滚动预测机制，缩短预测周期，提高预测灵活性\n\n")
                    elif "责任分析" in chart_name:
                        f.write("1. 对高责任得分的人员和区域进行针对性的库存管理培训\n"
                                "2. 完善销售与计划协同机制，减少预测与实际销售的差异\n"
                                "3. 建立库存责任制考核，将库存健康度纳入业绩评估\n\n")
                    elif "清库预测" in chart_name:
                        f.write("1. 对预计清库时间超过90天的批次，制定特别促销方案\n"
                                "2. 无法清库的批次考虑转移到其他销售渠道或市场\n"
                                "3. 建立清库监控机制，每周更新清库预测并调整营销策略\n\n")

                    f.write("-" * 60 + "\n\n")

                # 跨图表综合分析
                f.write("2. 综合分析结论\n")
                f.write("-" * 40 + "\n\n")

                # 风险批次概况
                f.write("2.1 库存风险状况分析\n")
                f.write(f"• 库存风险集中度：高风险批次({high_risk_pct:.1f}%)占比较{high_risk_pct > 20 and '高' or '低'}，"
                        f"显示库存健康度{high_risk_pct > 20 and '亟待改进' or '相对稳定'}\n")
                if '极高风险' in risk_counts:
                    f.write(f"• 极高风险批次({risk_counts['极高风险']}个)需要紧急处理，预计将导致资金占用和呆滞风险\n")

                # 加入价值角度分析
                f.write(f"• 库存价值风险：高风险批次价值占比{high_risk_value_pct:.1f}%，"
                        f"对公司财务状况影响{high_risk_value_pct > 25 and '显著' or '有限'}\n")

                # 主要问题产品分析
                if not high_value_risk.empty:
                    top_product = high_value_risk.iloc[0]
                    f.write("\n2.2 重点关注批次\n")
                    f.write(f"• 最高价值风险批次: {top_product['物料']}（{top_product['描述']}）\n")
                    f.write(f"• 批次价值: ¥{top_product['批次价值']:,.2f}, 风险等级: {top_product['风险程度']}\n")
                    f.write(f"• 库龄: {top_product['库龄']}天, 预计清库天数: "
                            f"{top_product['预计清库天数'] if top_product['预计清库天数'] != float('inf') else '无穷大'}\n")
                    f.write(f"• 处理建议: {top_product['建议措施']}\n")

                # 责任分析
                region_risk = self.batch_analysis.groupby('责任区域')['风险得分'].mean().sort_values(ascending=False)
                person_risk = self.batch_analysis.groupby('责任人')['风险得分'].mean().sort_values(ascending=False)

                f.write("\n2.3 责任区域与人员分析\n")
                if not region_risk.empty:
                    f.write(f"• 风险得分最高的区域: {region_risk.index[0]}（平均分{region_risk.iloc[0]:.1f}），"
                            f"建议进行区域库存管理流程审核\n")
                if not person_risk.empty:
                    f.write(f"• 风险得分最高的销售人员: {person_risk.index[0]}（平均分{person_risk.iloc[0]:.1f}），"
                            f"需重点培训库存与销售预测协同\n")

                    # 找出责任人的主要问题批次
                    problem_batches = self.batch_analysis[
                        self.batch_analysis['责任人'] == person_risk.index[0]
                        ].sort_values('风险得分', ascending=False)

                    if not problem_batches.empty:
                        top_batch = problem_batches.iloc[0]
                        f.write(f"  - 关键问题批次: {top_batch['物料']}，库龄{top_batch['库龄']}天，"
                                f"预计清库需要{top_batch['预计清库天数'] if top_batch['预计清库天数'] != float('inf') else '无法预计'}天\n")

                    # 预测问题
                bias_data = self.batch_analysis.copy()
                bias_data['预测偏差值'] = bias_data['预测偏差'].apply(
                    lambda x: float(x.rstrip('%')) / 100 if isinstance(x, str) and '%' in x else 0
                )
                # 限制预测偏差值在合理范围内，便于统计
                bias_data['预测偏差值'] = bias_data['预测偏差值'].apply(lambda x: min(max(x, -1.0), 1.0))
                high_bias = sum(abs(bias_data['预测偏差值']) > 0.3)  # 降低为30%阈值
                positive_bias = sum(bias_data['预测偏差值'] > 0.3)  # 预测过高
                negative_bias = sum(bias_data['预测偏差值'] < -0.3)  # 预测过低

                f.write("\n2.4 预测准确度分析\n")
                f.write(f"• 预测偏差问题批次: {high_bias}个产品的预测偏差超过30%\n")
                if high_bias > 0:
                    f.write(f"• 预测方向分析: {positive_bias}个批次预测过高(导致库存积压)，"
                            f"{negative_bias}个批次预测过低(可能导致缺货)\n")
                    f.write(f"• 预测改进方向: 需{positive_bias > negative_bias and '降低预测水平' or '提高预测灵敏度'}，"
                            f"重点关注{positive_bias > negative_bias and '销售能力评估' or '市场需求变化识别'}\n")

                # 改进建议
                f.write("\n3. 战略改进建议\n")
                f.write("-" * 40 + "\n\n")

                # 根据数据特点提供针对性建议
                if high_risk_pct > 25:
                    f.write("3.1 紧急风险缓解策略\n")
                    f.write("• 成立跨部门库存清理专项小组，优先处理极高风险批次\n")
                    f.write("• 实施临时促销计划，为高风险批次创建特别销售通道\n")
                    f.write("• 考虑批量转仓或调配至其他区域市场\n")
                    f.write("• 对长期积压批次进行折价销售授权\n\n")
                else:
                    f.write("3.1 风险管理策略\n")
                    f.write("• 建立定期库存审查机制，监控库存健康指标变化\n")
                    f.write("• 实施分级响应机制，对不同风险等级采取相应措施\n")
                    f.write("• 在库龄达到60天前提前干预潜在风险批次\n\n")

                # 预测改进建议
                if high_bias > (total_batches * 0.2):  # 如果预测偏差批次比例大于20%
                    f.write("3.2 预测体系改进\n")
                    f.write("• 重新评估预测算法和参数，引入更多影响因素\n")
                    f.write("• 缩短预测周期，实施滚动预测机制提高灵活性\n")
                    f.write("• 整合销售、营销和供应链数据，构建统一预测平台\n")
                    f.write("• 开展预测准确性培训，提升销售团队预测能力\n\n")

                # 责任管理建议
                f.write("3.3 责任管理体系优化\n")
                f.write("• 完善库存健康指标与绩效考核的关联机制\n")
                f.write("• 建立跨部门协作流程，共同应对库存风险\n")
                f.write("• 定期开展库存管理培训，提升整体库存意识\n")
                f.write("• 实施库存预警自动通知系统，及时提醒责任人\n\n")

                # 长期系统改进建议
                f.write("3.4 系统性改进措施\n")
                f.write("• 优化产品生命周期管理，建立产品退市机制\n")
                f.write("• 完善供应链柔性，提高对市场变化的响应速度\n")
                f.write("• 实施数据驱动的库存决策流程，减少主观判断偏差\n")
                f.write("• 建立库存风险预警自动化平台，提前识别潜在问题\n\n")

                # 结论
                f.write("\n" + "=" * 80 + "\n")
                f.write(" 报告结束 | 建议每月更新库存风险分析 | " + datetime.now().strftime('%Y-%m-%d') + "\n")
                f.write("=" * 80 + "\n")

            print(f"增强的可视化分析报告已保存至: {text_summary_path}")
            return text_summary_path

        except Exception as e:
            print(f"保存增强的可视化分析报告时出错: {str(e)}")
            # 尝试在当前目录保存
            alt_summary_path = os.path.join(os.getcwd(), f'库存风险分析洞察报告_{timestamp}.txt')
            try:
                with open(alt_summary_path, 'w', encoding='utf-8') as f:
                    f.write("报告生成失败，请检查文件权限和磁盘空间")
                print(f"已保存简化报告到当前目录: {alt_summary_path}")
                return alt_summary_path
            except:
                print("无法保存报告，请检查系统权限")
                return None

    def generate_reports(self):
                """生成分析报告和可视化"""
                print("正在生成报告...")
                timestamp = datetime.now().strftime('%Y%m%d%H%M%S')

                # 1.生成Excel报告
                report_path = self.generate_excel_report(timestamp)

                # 2.生成可视化图表
                self.generate_visualization(timestamp)

                print("报告生成完成！")
                return report_path

    def run(self):
                """运行完整的预警系统流程"""
                print("=" * 50)
                print("批次级别库存积压预警系统")
                print("=" * 50)

                # 1.加载数据
                self.load_data()

                # 2.分析数据
                self.analyze_data()

                # 3.生成报告
                report_path = self.generate_reports()

                print("=" * 50)
                print("预警系统运行完成！")
                print(f"报告已保存至: {report_path}")
                print("=" * 50)

                # 返回高风险批次数据
                high_risk_batches = self.batch_analysis[self.batch_analysis['风险程度'].isin(['极高风险', '高风险'])]
                return high_risk_batches

# 主函数
if __name__ == "__main__":
    import os
    import sys

    # 获取脚本所在的目录
    script_dir = os.path.dirname(os.path.abspath(__file__))

    # 设置文件路径 - 使用绝对路径
    # 首先尝试在当前目录查找文件
    inventory_file = os.path.join(script_dir, "含批次库存0221（2）.xlsx")
    shipping_file = os.path.join(script_dir, "2409~250224出货数据.xlsx")
    forecast_file = os.path.join(script_dir, "2409~2502人工预测.xlsx")
    price_file = os.path.join(script_dir, "单价.xlsx")  # 单价文件

    # 如果文件不在当前目录，尝试在桌面目录查找
    if not os.path.exists(inventory_file):
        # 获取桌面路径 - 增强错误处理和支持更多环境
        desktop_paths = []

        # Windows路径尝试
        if os.name == 'nt':
            desktop_paths.extend([
                os.path.join(os.path.expanduser('~'), 'Desktop'),
                os.path.join(os.path.expanduser('~'), '桌面'),
                os.path.join(os.environ.get('USERPROFILE', ''), 'Desktop'),
                os.path.join(os.environ.get('USERPROFILE', ''), '桌面')
            ])
        # macOS/Linux路径尝试
        else:
            desktop_paths.extend([
                os.path.join(os.path.expanduser('~'), 'Desktop'),
                os.path.join(os.path.expanduser('~'), '桌面')
            ])

        # 尝试所有可能的桌面路径
        desktop_path = None
        for path in desktop_paths:
            if os.path.exists(path):
                desktop_path = path
                break

        # 如果找到桌面路径，尝试在桌面查找文件
        if desktop_path:
            inventory_file = os.path.join(desktop_path, "含批次库存0221（2）.xlsx")
            shipping_file = os.path.join(desktop_path, "2409~250224出货数据.xlsx")
            forecast_file = os.path.join(desktop_path, "2409~2502人工预测.xlsx")
            price_file = os.path.join(desktop_path, "单价.xlsx")
        else:
            print("警告: 无法找到桌面路径，将使用当前目录")

    # 检查文件是否存在
    files_to_check = [
        ("库存文件", inventory_file),
        ("出货数据文件", shipping_file),
        ("预测文件", forecast_file),
        ("单价文件", price_file)
    ]

    missing_files = []
    for file_desc, file_path in files_to_check:
        if not os.path.exists(file_path):
            if file_desc == "单价文件":
                print(f"警告: {file_desc}不存在: {file_path}，将使用默认单价或内置价格表")
            else:
                missing_files.append(f"{file_desc}: {file_path}")

    if missing_files:
        print("错误: 无法找到以下文件：")
        for missing in missing_files:
            print(f" - {missing}")
        print("\n请确保文件路径正确，或者手动输入文件路径。")

        # 手动输入文件路径选项
        print("\n是否要手动输入文件路径？（y/n）")
        choice = input().strip().lower()

        if choice == 'y':
            print("请输入库存文件的完整路径：")
            inventory_file = input().strip().replace('"', '')

            print("请输入出货数据文件的完整路径：")
            shipping_file = input().strip().replace('"', '')

            print("请输入预测文件的完整路径：")
            forecast_file = input().strip().replace('"', '')

            print("请输入单价文件的完整路径（可选，按Enter跳过）：")
            price_input = input().strip().replace('"', '')
            if price_input:
                price_file = price_input
            else:
                price_file = None
        else:
            print("程序终止")
            sys.exit(1)

    print(f"使用以下文件：")
    print(f"库存文件: {inventory_file}")
    print(f"出货数据文件: {shipping_file}")
    print(f"预测文件: {forecast_file}")
    if price_file and os.path.exists(price_file):
        print(f"单价文件: {price_file}")
    else:
        print("使用默认单价或内置价格表")
        price_file = None

    try:
        # 创建预警系统实例并运行
        warning_system = BatchLevelInventoryWarningSystem(inventory_file, shipping_file, forecast_file, price_file)
        warning_system.load_data()
        warning_system.analyze_data()

        try:
            report_path = warning_system.generate_reports()
            print("=" * 50)
            print("预警系统运行完成！")
            print(f"报告已保存至: {report_path}")
            print("=" * 50)
        except Exception as report_error:
            print(f"警告: 生成报告时出错: {str(report_error)}")
            print("继续显示批次详情...")

        # 显示高风险批次，单独放在try块外确保总能执行
        high_risk_batches = warning_system.batch_analysis[
            warning_system.batch_analysis['风险程度'].isin(['极高风险', '高风险'])]

        # 显示高风险批次
        print("\n高风险批次概览：")
        if len(high_risk_batches) > 0:
            # 显示摘要信息
            summary_fields = ['物料', '描述', '批次日期', '批次库存', '库龄', '批次价值', '风险程度',
                              '积压原因', '预计清库天数', '责任区域', '责任人', '责任分析摘要', '建议措施']
            summary_data = high_risk_batches[summary_fields]

            for _, batch in summary_data.iterrows():
                print(f"物料: {batch['物料']} - {batch['描述']}")
                print(f"批次日期: {batch['批次日期']}")
                print(f"库存: {batch['批次库存']}，库龄: {batch['库龄']}天")
                print(f"批次价值: {batch['批次价值']:.2f}元")
                print(f"预计清库天数: {batch['预计清库天数'] if batch['预计清库天数'] != float('inf') else '无穷大'}")
                print(f"风险程度: {batch['风险程度']}")
                print(f"积压原因: {batch['积压原因']}")
                print(f"责任区域: {batch['责任区域']}，责任人: {batch['责任人']}")
                print(f"责任分析: {batch['责任分析摘要']}")  # 这行输出责任分析摘要
                print(f"建议措施: {batch['建议措施']}")
                print("-" * 30)
        else:
            print("没有发现高风险批次！")
    except Exception as e:
        print(f"错误: {str(e)}")
        import traceback

        traceback.print_exc()
        sys.exit(1)