import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
from datetime import datetime, timedelta
import requests
from io import BytesIO
import warnings
from scipy import stats
import xgboost as xgb
import lightgbm as lgb
from sklearn.model_selection import TimeSeriesSplit
from sklearn.metrics import mean_absolute_error
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
from collections import defaultdict, Counter
import pickle
import os
import math
from openpyxl import Workbook
from openpyxl.utils.dataframe import dataframe_to_rows
from openpyxl.styles import PatternFill, Font, Alignment, Border, Side

warnings.filterwarnings('ignore')

# ==================== È°µÈù¢ÈÖçÁΩÆ ====================
st.set_page_config(
    page_title="Êú∫Âô®Â≠¶‰π†È¢ÑÊµãÊéí‰∫ßÁ≥ªÁªü",
    page_icon="ü§ñ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# ==================== CSSÊ†∑ÂºèÔºà‰øùÊåÅÈôÑ‰ª∂1È£éÊ†ºÔºâ ====================
st.markdown("""
<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap');

    .stApp {
        font-family: 'Inter', sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        background-attachment: fixed;
    }

    /* ÊµÆÂä®Á≤íÂ≠êËÉåÊôØ */
    .stApp::before {
        content: '';
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background-image: 
            radial-gradient(circle at 25% 25%, rgba(255,255,255,0.1) 2px, transparent 2px),
            radial-gradient(circle at 75% 75%, rgba(255,255,255,0.1) 2px, transparent 2px);
        background-size: 100px 100px;
        animation: float 20s linear infinite;
        pointer-events: none; z-index: -1;
    }

    @keyframes float {
        0% { transform: translateY(0px) translateX(0px); }
        25% { transform: translateY(-20px) translateX(10px); }
        50% { transform: translateY(0px) translateX(-10px); }
        75% { transform: translateY(-10px) translateX(5px); }
        100% { transform: translateY(0px) translateX(0px); }
    }

    /* ‰∏ªÂÆπÂô® */
    .main .block-container {
        background: rgba(255,255,255,0.95);
        border-radius: 20px; padding: 2rem; margin-top: 2rem;
        box-shadow: 0 20px 60px rgba(0,0,0,0.1);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255,255,255,0.2);
    }

    /* ‰∏ªÊ†áÈ¢ò */
    .main-header {
        text-align: center; padding: 2.5rem 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #667eea 100%);
        background-size: 200% 200%;
        color: white; border-radius: 20px; margin-bottom: 2rem;
        animation: gradientShift 4s ease infinite, fadeInScale 1.2s ease-out;
        box-shadow: 0 15px 35px rgba(102, 126, 234, 0.4);
        position: relative; overflow: hidden;
    }

    .main-header::before {
        content: ''; position: absolute;
        top: -50%; left: -50%; width: 200%; height: 200%;
        background: linear-gradient(45deg, transparent, rgba(255,255,255,0.15), transparent);
        animation: shimmer 3s linear infinite;
    }

    @keyframes gradientShift {
        0%, 100% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
    }

    @keyframes shimmer {
        0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
        100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
    }

    @keyframes fadeInScale {
        from { opacity: 0; transform: translateY(-30px) scale(0.9); }
        to { opacity: 1; transform: translateY(0) scale(1); }
    }

    /* Áªü‰∏ÄÊåáÊ†áÂç°ÁâáÊ†∑Âºè */
    .metric-card {
        background: linear-gradient(145deg, #ffffff 0%, #f8fafc 100%);
        padding: 1.5rem; border-radius: 18px; text-align: center; height: 100%;
        box-shadow: 0 8px 25px rgba(0,0,0,0.08), 0 3px 10px rgba(0,0,0,0.03);
        border: 1px solid rgba(255,255,255,0.3);
        transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        animation: slideUp 0.8s ease-out;
        position: relative; overflow: hidden;
        backdrop-filter: blur(10px);
    }

    .metric-card::before {
        content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
        background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.1), transparent);
        transition: left 0.6s ease;
    }

    .metric-card:hover {
        transform: translateY(-8px) scale(1.02);
        box-shadow: 0 20px 40px rgba(0,0,0,0.12), 0 10px 20px rgba(102, 126, 234, 0.15);
    }

    .metric-card:hover::before { left: 100%; }

    @keyframes slideUp {
        from { opacity: 0; transform: translateY(30px) scale(0.95); }
        to { opacity: 1; transform: translateY(0) scale(1); }
    }

    /* ÊåáÊ†áÊï∞ÂÄºÊ†∑Âºè */
    .metric-value {
        font-size: 2.2rem; font-weight: 800; margin-bottom: 0.5rem;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        background-clip: text; color: #667eea;
        animation: valueGlow 2s ease-in-out infinite alternate;
        line-height: 1.1;
    }

    .big-value {
        font-size: 2.8rem; font-weight: 900; margin-bottom: 0.3rem;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        background-clip: text; color: #667eea;
        animation: valueGlow 2s ease-in-out infinite alternate;
        line-height: 1;
    }

    @keyframes valueGlow {
        from { filter: brightness(1); }
        to { filter: brightness(1.1); }
    }

    .metric-label {
        color: #374151; font-size: 0.95rem; font-weight: 600;
        margin-top: 0.5rem; letter-spacing: 0.3px;
    }

    .metric-sublabel {
        color: #6b7280; font-size: 0.8rem; margin-top: 0.4rem;
        font-weight: 500; font-style: italic;
    }

    /* Ê†áÁ≠æÈ°µÊ†∑Âºè */
    .stTabs [data-baseweb="tab-list"] {
        gap: 8px; background: linear-gradient(145deg, #f8fafc 0%, #e2e8f0 100%);
        padding: 0.6rem; border-radius: 12px;
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.06);
    }

    .stTabs [data-baseweb="tab"] {
        height: 45px; padding: 0 20px;
        background: linear-gradient(145deg, #ffffff 0%, #f8fafc 100%);
        border-radius: 10px; border: 1px solid rgba(102, 126, 234, 0.15);
        font-weight: 600; font-size: 0.85rem;
        transition: all 0.3s ease;
    }

    .stTabs [data-baseweb="tab"]:hover {
        transform: translateY(-2px); 
        box-shadow: 0 8px 16px rgba(102, 126, 234, 0.15);
    }

    .stTabs [aria-selected="true"] {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white; border: none;
        box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
    }

    /* Ê¥ûÂØüÂç°Áâá */
    .insight-card {
        background: linear-gradient(145deg, #ffffff 0%, #f8fafc 100%);
        border-left: 4px solid #667eea; border-radius: 12px;
        padding: 1.2rem; margin: 0.8rem 0;
        box-shadow: 0 6px 20px rgba(0,0,0,0.06);
        animation: slideInLeft 0.6s ease-out;
        transition: all 0.3s ease;
    }

    .insight-card:hover {
        transform: translateX(5px) translateY(-2px);
        box-shadow: 0 10px 30px rgba(102, 126, 234, 0.12);
    }

    @keyframes slideInLeft {
        from { opacity: 0; transform: translateX(-20px); }
        to { opacity: 1; transform: translateX(0); }
    }

    .insight-card h4 {
        color: #1f2937; margin-bottom: 0.8rem;
        font-weight: 700; font-size: 1rem;
    }

    /* ÂõæË°®Ê†áÈ¢òÂÆπÂô® */
    .chart-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        background-size: 200% 200%;
        border-radius: 12px;
        padding: 1.2rem 1.8rem;
        margin-bottom: 1.5rem;
        box-shadow: 0 8px 25px rgba(102, 126, 234, 0.25);
        position: relative;
        overflow: hidden;
        animation: gradientFlow 6s ease infinite;
        transition: all 0.3s ease;
    }

    .chart-header:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 35px rgba(102, 126, 234, 0.35);
    }

    /* Ê∏êÂèòÊµÅÂä®Âä®Áîª */
    @keyframes gradientFlow {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }

    /* ÂÖâÊ≥ΩÊïàÊûú */
    .chart-header::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, 
            transparent, 
            rgba(255, 255, 255, 0.1), 
            transparent
        );
        animation: shine 3s ease-in-out infinite;
    }

    @keyframes shine {
        0% { left: -100%; }
        50%, 100% { left: 200%; }
    }

    /* ÂõæË°®Ê†áÈ¢òÊ†∑Âºè */
    .chart-title {
        color: #ffffff;
        font-size: 1.4rem;
        font-weight: 800;
        margin-bottom: 0.3rem;
        text-align: left;
        text-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        letter-spacing: 0.5px;
        line-height: 1.2;
        animation: fadeInSlide 0.8s ease-out;
    }

    .chart-subtitle {
        color: rgba(255, 255, 255, 0.85);
        font-size: 0.9rem;
        font-weight: 400;
        text-align: left;
        line-height: 1.4;
        text-shadow: 0 1px 4px rgba(0, 0, 0, 0.15);
        animation: fadeInSlide 1s ease-out;
    }

    @keyframes fadeInSlide {
        from {
            opacity: 0;
            transform: translateX(-20px);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }

    /* Âä®ÁîªÂª∂Ëøü */
    .metric-card:nth-child(1) { animation-delay: 0.1s; }
    .metric-card:nth-child(2) { animation-delay: 0.2s; }
    .metric-card:nth-child(3) { animation-delay: 0.3s; }
    .metric-card:nth-child(4) { animation-delay: 0.4s; }
    .metric-card:nth-child(5) { animation-delay: 0.5s; }
    .metric-card:nth-child(6) { animation-delay: 0.6s; }
    .metric-card:nth-child(7) { animation-delay: 0.7s; }
    .metric-card:nth-child(8) { animation-delay: 0.8s; }

    /* ÂìçÂ∫îÂºè */
    @media (max-width: 768px) {
        .metric-value, .big-value { font-size: 1.8rem; }
        .metric-card { padding: 1rem; margin: 0.5rem 0; }
        .main-header { padding: 1.5rem 0; }
    }

    /* Á°Æ‰øùÊñáÂ≠óÈ¢úËâ≤ */
    h1, h2, h3, h4, h5, h6 { color: #1f2937 !important; }
    p, span, div { color: #374151; }
</style>
""", unsafe_allow_html=True)

# ==================== ÂÖ®Â±ÄÂèòÈáèÂíåÂáΩÊï∞ ====================
VERBOSE = False
CURRENT_LOG_LEVEL = 2  # WARNING

def calculate_accuracy(predicted, actual):
    """Áªü‰∏ÄÁöÑÂáÜÁ°ÆÁéáËÆ°ÁÆóÊñπÊ≥ï"""
    absolute_threshold = 20
    
    if actual == 0:
        return 100 if predicted <= absolute_threshold else 0
    
    absolute_error = abs(predicted - actual)
    
    if absolute_error <= absolute_threshold:
        return 100
    
    relative_error = (absolute_error / actual) * 100
    accuracy = max(0, 100 - relative_error)
    
    return accuracy

def log(message, level="INFO", force=False):
    """Êó•ÂøóÂáΩÊï∞"""
    if force or VERBOSE:
        print(f"[{level}] {message}")

# ==================== Êï∞ÊçÆÂ§ÑÁêÜÁ±ª ====================
class DataPreprocessor:
    """Êï∞ÊçÆÈ¢ÑÂ§ÑÁêÜÂô®"""
    def __init__(self):
        self.z_threshold = 3.0
        self.smooth_window = 3
    
    def detect_outliers(self, data, method='zscore'):
        """Ê£ÄÊµãÂºÇÂ∏∏ÂÄº"""
        if len(data) < 4:
            return []
        
        if method == 'zscore':
            z_scores = np.abs(stats.zscore(data))
            return np.where(z_scores > self.z_threshold)[0]
        elif method == 'iqr':
            q1 = np.percentile(data, 25)
            q3 = np.percentile(data, 75)
            iqr = q3 - q1
            lower_bound = q1 - 1.5 * iqr
            upper_bound = q3 + 1.5 * iqr
            return np.where((data < lower_bound) | (data > upper_bound))[0]
        
        return []
    
    def smooth_data(self, data, window_size=None):
        """Âπ≥ÊªëÊï∞ÊçÆ"""
        if window_size is None:
            window_size = self.smooth_window
        
        if len(data) < window_size:
            return data
        
        smoothed_data = np.zeros_like(data)
        for i in range(len(data)):
            start = max(0, i - window_size + 1)
            smoothed_data[i] = np.mean(data[start:i + 1])
        
        return smoothed_data

# ==================== ‰∫ßÂìÅÂàÜÁªÑÂô®Á±ª ====================
class ProductGrouper:
    """‰∫ßÂìÅÂàÜÁªÑÂô®"""
    def __init__(self):
        self.cv_threshold = 0.5
        self.seasonal_threshold = 0.2
        self.groups = {}
    
    def calculate_cv(self, data):
        """ËÆ°ÁÆóÂèòÂºÇÁ≥ªÊï∞"""
        if np.mean(data) == 0:
            return float('inf')
        return np.std(data) / np.mean(data)
    
    def detect_seasonality(self, monthly_data):
        """Ê£ÄÊµãÂ≠£ËäÇÊÄß"""
        if len(monthly_data) < 12:
            return False, 1.0
        
        monthly_avg = {}
        for i, val in enumerate(monthly_data):
            month = (i % 12) + 1
            if month not in monthly_avg:
                monthly_avg[month] = []
            monthly_avg[month].append(val)
        
        for month in monthly_avg:
            monthly_avg[month] = np.mean(monthly_avg[month])
        
        overall_avg = np.mean(list(monthly_avg.values()))
        max_diff = max(monthly_avg.values()) - min(monthly_avg.values())
        relative_diff = max_diff / overall_avg if overall_avg > 0 else 0
        
        is_seasonal = relative_diff > self.seasonal_threshold
        
        return is_seasonal, monthly_avg
    
    def group_products(self, shipping_data, product_codes=None):
        """ÂØπ‰∫ßÂìÅËøõË°åÂàÜÁªÑ"""
        monthly_sales = shipping_data.copy()
        monthly_sales['Êúà‰ªΩ'] = monthly_sales['ËÆ¢ÂçïÊó•Êúü'].dt.to_period('M')
        monthly_sales = monthly_sales.groupby(['Êúà‰ªΩ', '‰∫ßÂìÅ‰ª£Á†Å'])['Ê±ÇÂíåÈ°π:Êï∞ÈáèÔºàÁÆ±Ôºâ'].sum().reset_index()
        
        if product_codes is None:
            product_codes = monthly_sales['‰∫ßÂìÅ‰ª£Á†Å'].unique()
        
        for product in product_codes:
            product_sales = monthly_sales[monthly_sales['‰∫ßÂìÅ‰ª£Á†Å'] == product].sort_values('Êúà‰ªΩ')
            
            if len(product_sales) < 3:
                self.groups[product] = 'stable'
                continue
            
            sales_values = product_sales['Ê±ÇÂíåÈ°π:Êï∞ÈáèÔºàÁÆ±Ôºâ'].values
            cv = self.calculate_cv(sales_values)
            is_seasonal, _ = self.detect_seasonality(sales_values)
            
            if is_seasonal:
                group_type = 'seasonal'
            elif cv > self.cv_threshold:
                group_type = 'volatile'
            else:
                group_type = 'stable'
            
            self.groups[product] = group_type
        
        return self.groups

# ==================== MLÊ®°ÂûãÈÄâÊã©Âô® ====================
class MLModelSelector:
    """Ê®°ÂûãÈÄâÊã©Âô®"""
    def __init__(self, data_tracker=None):
        self.data_tracker = data_tracker
        self.models = {}
        self.best_model_records = {}
        self.model_cache_path = 'ml_models_cache/'
        
        if not os.path.exists(self.model_cache_path):
            os.makedirs(self.model_cache_path)
    
    def _create_xgboost_model(self):
        """ÂàõÂª∫XGBoostÊ®°Âûã"""
        return xgb.XGBRegressor(
            n_estimators=50,
            learning_rate=0.05,
            max_depth=2,
            min_child_weight=1,
            gamma=0,
            subsample=0.9,
            colsample_bytree=0.9,
            objective='reg:squarederror',
            verbosity=0,
            random_state=42
        )
    
    def _create_lightgbm_model(self):
        """ÂàõÂª∫LightGBMÊ®°Âûã"""
        return lgb.LGBMRegressor(
            n_estimators=50,
            learning_rate=0.05,
            max_depth=2,
            min_child_samples=2,
            subsample=0.9,
            colsample_bytree=0.9,
            objective='regression',
            verbose=-1,
            min_data_in_leaf=1,
            min_sum_hessian_in_leaf=0.001,
            random_state=42
        )
    
    def select_best_model(self, product_code, features_df, target, time_col='Êúà‰ªΩ'):
        """ÈÄâÊã©ÊúÄ‰Ω≥Ê®°Âûã - ÁÆÄÂåñÁâàÔºåÂßãÁªà‰ΩøÁî®XGBoost"""
        log(f"‰∏∫‰∫ßÂìÅ {product_code} ÈÄâÊã©ÊúÄ‰Ω≥Ê®°Âûã...")
        
        if len(features_df) < 3:
            log(f"‰∫ßÂìÅ {product_code} Êï∞ÊçÆÈáèÊûÅÂ∞ëÔºå‰ΩøÁî®Êâ©Â±ïÁßªÂä®Âπ≥ÂùáÊ®°Âûã")
            return {
                'model_name': 'extended_ma',
                'model': {'model_type': 'extended_ma'},
                'score': 0,
                'feature_cols': None,
                'last_update': datetime.now()
            }
        
        features_df = features_df.sort_values(time_col).reset_index(drop=True)
        feature_cols = [col for col in features_df.columns if col != time_col and col != target]
        
        model_name = 'xgboost'
        is_new_product = len(features_df) < 6
        
        if is_new_product:
            model = self._create_xgboost_model()
            log(f"‰∫ßÂìÅ {product_code} Êï∞ÊçÆÈáèËæÉÂ∞ëÔºå‰ΩøÁî®ÁÆÄÂåñXGBoostÊ®°Âûã")
        else:
            model = xgb.XGBRegressor(
                n_estimators=100,
                learning_rate=0.05,
                max_depth=3,
                subsample=0.8,
                colsample_bytree=0.8,
                objective='reg:squarederror',
                verbosity=0,
                random_state=42
            )
            log(f"‰∫ßÂìÅ {product_code} Êï∞ÊçÆÂÖÖË∂≥Ôºå‰ΩøÁî®Ê†áÂáÜXGBoostÊ®°Âûã")
        
        X = features_df[feature_cols]
        y = features_df[target]
        model.fit(X, y)
        
        train_predictions = model.predict(X)
        score = mean_absolute_error(y, train_predictions)
        
        best_model_info = {
            'model_name': model_name,
            'model': model,
            'score': score,
            'feature_cols': feature_cols,
            'last_update': datetime.now()
        }
        
        log(f"‰∫ßÂìÅ {product_code} ÁöÑÊúÄ‰Ω≥Ê®°Âûã: {model_name}, ÂæóÂàÜ: {score:.2f}")
        return best_model_info

# ==================== MLÈ¢ÑÊµãÂô® ====================
class MLPredictor:
    """Êú∫Âô®Â≠¶‰π†È¢ÑÊµãÂô®"""
    def __init__(self, shipping_data, product_info, promotion_data, data_tracker=None):
        self.shipping_data = shipping_data
        self.product_info = product_info
        self.promotion_data = promotion_data
        self.data_tracker = data_tracker
        self.current_date = datetime.now()
        self.model_selector = MLModelSelector(data_tracker)
        self.data_preprocessor = DataPreprocessor()
        
        self.special_periods = {
            'ÂÑøÁ´•ËäÇ': (5, 7),
            'ÊöëÂÅá': (7, 9),
            'Êò•ËäÇ': (1, 3)
        }
        
        self.predictions = {}
    
    def prepare_features(self, product_code):
        """ÂáÜÂ§áÈ¢ÑÊµãÁâπÂæÅ"""
        product_data = self.shipping_data[self.shipping_data['‰∫ßÂìÅ‰ª£Á†Å'] == product_code].copy()
        
        if product_data.empty:
            log(f"‰∫ßÂìÅ {product_code} Ê≤°ÊúâÈîÄÂîÆÊï∞ÊçÆ")
            return None
        
        product_data['Êúà‰ªΩ'] = product_data['ËÆ¢ÂçïÊó•Êúü'].dt.to_period('M')
        monthly_sales = product_data.groupby('Êúà‰ªΩ')['Ê±ÇÂíåÈ°π:Êï∞ÈáèÔºàÁÆ±Ôºâ'].sum().reset_index()
        monthly_sales['Êúà‰ªΩ'] = monthly_sales['Êúà‰ªΩ'].dt.to_timestamp()
        monthly_sales = monthly_sales.sort_values('Êúà‰ªΩ')
        
        total_sales = monthly_sales['Ê±ÇÂíåÈ°π:Êï∞ÈáèÔºàÁÆ±Ôºâ'].sum()
        avg_monthly_sales = monthly_sales['Ê±ÇÂíåÈ°π:Êï∞ÈáèÔºàÁÆ±Ôºâ'].mean()
        sales_std = monthly_sales['Ê±ÇÂíåÈ°π:Êï∞ÈáèÔºàÁÆ±Ôºâ'].std()
        sales_cv = sales_std / avg_monthly_sales if avg_monthly_sales > 0 else 0
        
        is_new_product = len(monthly_sales) < 6
        
        features = []
        
        for i, row in monthly_sales.iterrows():
            month = row['Êúà‰ªΩ']
            sales = row['Ê±ÇÂíåÈ°π:Êï∞ÈáèÔºàÁÆ±Ôºâ']
            
            feature = {
                'Êúà‰ªΩ': month,
                'ÈîÄÈáè': sales,
                'Êúà‰ªΩ_sin': np.sin(2 * np.pi * month.month / 12),
                'Êúà‰ªΩ_cos': np.cos(2 * np.pi * month.month / 12),
                'Â≠£Â∫¶': (month.month - 1) // 3 + 1,
                'Âπ¥‰ªΩ': month.year,
                'ÊúàÂè∑': month.month,
                'ÊòØÊò•Â≠£': 3 <= month.month <= 5,
                'ÊòØÂ§èÂ≠£': 6 <= month.month <= 8,
                'ÊòØÁßãÂ≠£': 9 <= month.month <= 11,
                'ÊòØÂÜ¨Â≠£': month.month == 12 or month.month <= 2,
                'ÊòØÊò•ËäÇÊúüÈó¥': 1 <= month.month <= 2,
                'ÊòØÂÑøÁ´•ËäÇÊúüÈó¥': 5 <= month.month <= 6,
                'ÊòØÊöëÂÅáÊúüÈó¥': 7 <= month.month <= 8,
                'ÊòØÊñ∞ÂìÅ': is_new_product,
                'Âπ≥ÂùáÊúàÈîÄÈáè': avg_monthly_sales,
                'ÈîÄÈáèÂèòÂºÇÁ≥ªÊï∞': sales_cv,
            }
            
            if self.data_tracker and hasattr(self.data_tracker, 'get_product_group'):
                group_type = self.data_tracker.get_product_group(product_code)
                feature['‰∫ßÂìÅÂàÜÁªÑ_stable'] = 1 if group_type == 'stable' else 0
                feature['‰∫ßÂìÅÂàÜÁªÑ_volatile'] = 1 if group_type == 'volatile' else 0
                feature['‰∫ßÂìÅÂàÜÁªÑ_seasonal'] = 1 if group_type == 'seasonal' else 0
            else:
                feature['‰∫ßÂìÅÂàÜÁªÑ_stable'] = 1
                feature['‰∫ßÂìÅÂàÜÁªÑ_volatile'] = 0
                feature['‰∫ßÂìÅÂàÜÁªÑ_seasonal'] = 0
            
            features.append(feature)
        
        features_df = pd.DataFrame(features)
        
        # Ê∑ªÂä†ÂéÜÂè≤ÈîÄÈáèÁâπÂæÅ
        max_lag = min(12, len(features_df))
        for lag in range(1, max_lag):
            features_df[f'ÈîÄÈáè_lag{lag}'] = features_df['ÈîÄÈáè'].shift(lag)
        
        # Ê∑ªÂä†ÁßªÂä®Âπ≥ÂùáÁâπÂæÅ
        if is_new_product:
            window_sizes = [2, 3]
        else:
            window_sizes = [3, 6, 12]
        
        for window in window_sizes:
            if window <= len(features_df):
                features_df[f'ÈîÄÈáè_ma{window}'] = features_df['ÈîÄÈáè'].rolling(window=window).mean()
        
        # Ê∑ªÂä†Ë∂ãÂäøÁâπÂæÅ
        features_df['ÈîÄÈáè_trend'] = 0.0
        
        if len(features_df) >= 3:
            recent_data = features_df.tail(min(6, len(features_df)))
            x = np.arange(len(recent_data))
            y = recent_data['ÈîÄÈáè'].values
            
            try:
                slope, intercept, r_value, p_value, std_err = stats.linregress(x, y)
                if not np.isnan(slope):
                    norm_slope = slope / recent_data['ÈîÄÈáè'].mean() if recent_data['ÈîÄÈáè'].mean() > 0 else 0
                    features_df.loc[features_df.index[-3:], 'ÈîÄÈáè_trend'] = norm_slope
            except:
                pass
        
        # Ê∑ªÂä†ÂÆ¢Êà∑ÁâπÂæÅ
        if 'ÂÆ¢Êà∑‰ª£Á†Å' in self.shipping_data.columns:
            customer_sales = product_data.groupby('ÂÆ¢Êà∑‰ª£Á†Å')['Ê±ÇÂíåÈ°π:Êï∞ÈáèÔºàÁÆ±Ôºâ'].sum()
            total_sales = customer_sales.sum()
            
            if total_sales > 0:
                herfindahl_index = sum((sales / total_sales) ** 2 for sales in customer_sales)
                features_df['ÂÆ¢Êà∑ÈõÜ‰∏≠Â∫¶'] = herfindahl_index
                
                main_customers = [customer for customer, sales in customer_sales.items()
                                  if sales / total_sales >= 0.1]
                features_df['‰∏ªË¶ÅÂÆ¢Êà∑Êï∞'] = len(main_customers)
                
                main_customer_contribution = sum(sales for customer, sales in customer_sales.items()
                                                 if customer in main_customers) / total_sales
                features_df['‰∏ªË¶ÅÂÆ¢Êà∑Ë¥°ÁåÆÁéá'] = main_customer_contribution
                
                if not customer_sales.empty:
                    features_df['ÊúÄÂ§ßÂÆ¢Êà∑Ë¥°ÁåÆÁéá'] = customer_sales.max() / total_sales
            else:
                features_df['ÂÆ¢Êà∑ÈõÜ‰∏≠Â∫¶'] = 0
                features_df['‰∏ªË¶ÅÂÆ¢Êà∑Êï∞'] = 0
                features_df['‰∏ªË¶ÅÂÆ¢Êà∑Ë¥°ÁåÆÁéá'] = 0
                features_df['ÊúÄÂ§ßÂÆ¢Êà∑Ë¥°ÁåÆÁéá'] = 0
        else:
            features_df['ÂÆ¢Êà∑ÈõÜ‰∏≠Â∫¶'] = 0
            features_df['‰∏ªË¶ÅÂÆ¢Êà∑Êï∞'] = 0
            features_df['‰∏ªË¶ÅÂÆ¢Êà∑Ë¥°ÁåÆÁéá'] = 0
            features_df['ÊúÄÂ§ßÂÆ¢Êà∑Ë¥°ÁåÆÁéá'] = 0
        
        # Â§ÑÁêÜNaNÂÄº
        lag_columns = [col for col in features_df.columns if col.startswith('ÈîÄÈáè_lag')]
        for col in lag_columns:
            features_df[col] = features_df[col].fillna(0)
        
        ma_columns = [col for col in features_df.columns if col.startswith('ÈîÄÈáè_ma')]
        for col in ma_columns:
            features_df[col] = features_df[col].fillna(features_df['ÈîÄÈáè'])
        
        features_df['ÈîÄÈáè_trend'] = features_df['ÈîÄÈáè_trend'].fillna(1.0)
        
        return features_df
    
    def predict_next_months(self, product_code, horizon=4, current_date=None):
        """È¢ÑÊµãÊú™Êù•Âá†‰∏™Êúà"""
        if current_date is None:
            current_date = self.current_date
        
        log(f"‰ΩøÁî®Áªü‰∏ÄXGBoostÊ®°ÂûãÈ¢ÑÊµã‰∫ßÂìÅ {product_code}")
        
        features_df = self.prepare_features(product_code)
        
        if features_df is None or features_df.empty:
            log(f"‰∫ßÂìÅ {product_code} Ê≤°ÊúâË∂≥Â§üÊï∞ÊçÆÔºåÊó†Ê≥ïÈ¢ÑÊµã")
            return None
        
        avg_monthly_sales = features_df['ÈîÄÈáè'].mean() if 'ÈîÄÈáè' in features_df.columns else 0
        is_new_product = len(features_df) < 6
        sales_std = features_df['ÈîÄÈáè'].std() if 'ÈîÄÈáè' in features_df.columns else 0
        sales_cv = sales_std / avg_monthly_sales if avg_monthly_sales > 0 else 0
        
        if len(features_df) < 3:
            log(f"‰∫ßÂìÅ {product_code} Êï∞ÊçÆÈáèÊûÅÂ∞ëÔºå‰ΩøÁî®ÁÆÄÂçïÂπ≥ÂùáÈ¢ÑÊµã")
            conservative_factor = 0.9
            avg_sales = features_df['ÈîÄÈáè'].mean()
            predictions = [round(avg_sales * conservative_factor)] * horizon
            return predictions
        
        X = features_df.drop(['Êúà‰ªΩ', 'ÈîÄÈáè'], axis=1)
        y = features_df['ÈîÄÈáè']
        
        if is_new_product:
            model = xgb.XGBRegressor(
                n_estimators=50,
                learning_rate=0.05,
                max_depth=2,
                min_child_weight=2,
                subsample=0.9,
                colsample_bytree=0.9,
                objective='reg:squarederror',
                verbosity=0,
                random_state=42
            )
        else:
            model = xgb.XGBRegressor(
                n_estimators=100,
                learning_rate=0.05,
                max_depth=3,
                subsample=0.8,
                colsample_bytree=0.8,
                objective='reg:squarederror',
                verbosity=0,
                random_state=42
            )
        
        model.fit(X, y)
        
        feature_importance = model.feature_importances_
        feature_names = X.columns
        importance_df = pd.DataFrame({'feature': feature_names, 'importance': feature_importance})
        importance_df = importance_df.sort_values('importance', ascending=False)
        
        top_features = importance_df.head(5)
        log(f"‰∫ßÂìÅ {product_code} ÁöÑÂâç5‰∏™ÈáçË¶ÅÁâπÂæÅ:")
        for _, row in top_features.iterrows():
            log(f"  {row['feature']}: {row['importance']:.4f}")
        
        predictions = []
        last_features = X.iloc[-1].copy()
        
        if is_new_product:
            base_conservative_factor = 0.9
        elif sales_cv > 0.5:
            base_conservative_factor = 0.92
        else:
            base_conservative_factor = 0.95
        
        for i in range(horizon):
            target_month = current_date.month + i
            target_year = current_date.year
            if target_month > 12:
                target_month -= 12
                target_year += 1
            
            next_month = datetime(target_year, target_month, 1)
            if 'ÊúàÂè∑' in last_features:
                last_features['ÊúàÂè∑'] = next_month.month
            if 'Âπ¥‰ªΩ' in last_features:
                last_features['Âπ¥‰ªΩ'] = next_month.year
            if 'Êúà‰ªΩ_sin' in last_features:
                last_features['Êúà‰ªΩ_sin'] = np.sin(2 * np.pi * next_month.month / 12)
            if 'Êúà‰ªΩ_cos' in last_features:
                last_features['Êúà‰ªΩ_cos'] = np.cos(2 * np.pi * next_month.month / 12)
            if 'Â≠£Â∫¶' in last_features:
                last_features['Â≠£Â∫¶'] = (next_month.month - 1) // 3 + 1
            
            if 'ÊòØÊò•Â≠£' in last_features:
                last_features['ÊòØÊò•Â≠£'] = 3 <= next_month.month <= 5
            if 'ÊòØÂ§èÂ≠£' in last_features:
                last_features['ÊòØÂ§èÂ≠£'] = 6 <= next_month.month <= 8
            if 'ÊòØÁßãÂ≠£' in last_features:
                last_features['ÊòØÁßãÂ≠£'] = 9 <= next_month.month <= 11
            if 'ÊòØÂÜ¨Â≠£' in last_features:
                last_features['ÊòØÂÜ¨Â≠£'] = next_month.month == 12 or next_month.month <= 2
            
            if 'ÊòØÊò•ËäÇÊúüÈó¥' in last_features:
                last_features['ÊòØÊò•ËäÇÊúüÈó¥'] = 1 <= next_month.month <= 2
            if 'ÊòØÂÑøÁ´•ËäÇÊúüÈó¥' in last_features:
                last_features['ÊòØÂÑøÁ´•ËäÇÊúüÈó¥'] = 5 <= next_month.month <= 6
            if 'ÊòØÊöëÂÅáÊúüÈó¥' in last_features:
                last_features['ÊòØÊöëÂÅáÊúüÈó¥'] = 7 <= next_month.month <= 8
            
            try:
                prediction = model.predict(last_features.values.reshape(1, -1))[0]
                prediction = max(0, prediction)
                prediction_horizon_factor = base_conservative_factor * (1 - i * 0.01)
                adjusted_prediction = prediction * prediction_horizon_factor
            except Exception as e:
                log(f"È¢ÑÊµãÂá∫Èîô: {e}")
                adjusted_prediction = avg_monthly_sales * base_conservative_factor
            
            predictions.append(round(adjusted_prediction))
            
            for lag in range(min(12, len(features_df)), 1, -1):
                lag_col = f'ÈîÄÈáè_lag{lag}'
                prev_lag_col = f'ÈîÄÈáè_lag{lag - 1}'
                if lag_col in last_features and prev_lag_col in last_features:
                    last_features[lag_col] = last_features[prev_lag_col]
            
            if 'ÈîÄÈáè_lag1' in last_features:
                last_features['ÈîÄÈáè_lag1'] = adjusted_prediction
            
            for window in [3, 6, 12]:
                ma_col = f'ÈîÄÈáè_ma{window}'
                if ma_col in last_features:
                    if i >= window - 1:
                        last_features[ma_col] = np.mean(predictions[-window:])
                    else:
                        hist_values = y.iloc[-(window - i - 1):].values.tolist() if i < window - 1 else []
                        all_values = hist_values + predictions
                        last_features[ma_col] = np.mean(all_values[-window:])
        
        self.predictions[product_code] = predictions
        
        if is_new_product and len(y) > 0:
            max_historical = y.max()
            for i in range(len(predictions)):
                if predictions[i] > max_historical * 1.5:
                    predictions[i] = round(max_historical * 1.5)
        
        return predictions

# ==================== ÂÆ¢Êà∑ÂàÜÊûêÁ±ª ====================
class CustomerProductAnalyzer:
    """ÂÆ¢Êà∑‰∫ßÂìÅÂàÜÊûêÂô®"""
    def analyze_dependencies(self, shipping_data):
        """ÂàÜÊûê‰∫ßÂìÅÂØπÂÆ¢Êà∑ÁöÑ‰æùËµñÂÖ≥Á≥ª"""
        if 'ÂÆ¢Êà∑‰ª£Á†Å' not in shipping_data.columns:
            log("Êï∞ÊçÆ‰∏≠‰∏çÂåÖÂê´ÂÆ¢Êà∑‰ø°ÊÅØÔºåÊó†Ê≥ïÂàÜÊûêÂÆ¢Êà∑‰æùËµñÂÖ≥Á≥ª")
            return {}
        
        result = {}
        
        product_customer_sales = shipping_data.groupby(['‰∫ßÂìÅ‰ª£Á†Å', 'ÂÆ¢Êà∑‰ª£Á†Å'])['Ê±ÇÂíåÈ°π:Êï∞ÈáèÔºàÁÆ±Ôºâ'].sum().reset_index()
        product_total_sales = product_customer_sales.groupby('‰∫ßÂìÅ‰ª£Á†Å')['Ê±ÇÂíåÈ°π:Êï∞ÈáèÔºàÁÆ±Ôºâ'].sum().to_dict()
        
        for _, row in product_customer_sales.iterrows():
            product = row['‰∫ßÂìÅ‰ª£Á†Å']
            customer = row['ÂÆ¢Êà∑‰ª£Á†Å']
            sales = row['Ê±ÇÂíåÈ°π:Êï∞ÈáèÔºàÁÆ±Ôºâ']
            
            total_sales = product_total_sales.get(product, 0)
            if total_sales > 0:
                contribution = sales / total_sales
                
                if product not in result:
                    result[product] = []
                
                if contribution >= 0.1:
                    result[product].append({
                        'customer': customer,
                        'contribution': contribution,
                        'sales': sales
                    })
        
        for product in result:
            result[product] = sorted(result[product], key=lambda x: x['contribution'], reverse=True)
        
        return result

class CustomerActivityMonitor:
    """ÂÆ¢Êà∑Ê¥ªË∑ÉÂ∫¶ÁõëÊéß"""
    def __init__(self, months_threshold=3):
        self.months_threshold = months_threshold
    
    def check_customer_activity(self, shipping_data, product_customer_deps, current_date=None):
        """Ê£ÄÊü•ÂÆ¢Êà∑Ê¥ªË∑ÉÁä∂ÊÄÅ"""
        if 'ÂÆ¢Êà∑‰ª£Á†Å' not in shipping_data.columns:
            log("Êï∞ÊçÆ‰∏≠‰∏çÂåÖÂê´ÂÆ¢Êà∑‰ø°ÊÅØÔºåÊó†Ê≥ïÁõëÊéßÂÆ¢Êà∑Ê¥ªË∑ÉÂ∫¶")
            return {}
        
        if current_date is None:
            current_date = datetime.now()
        
        activity_status = {}
        
        for product, customers in product_customer_deps.items():
            activity_status[product] = {}
            
            for customer_info in customers[:min(3, len(customers))]:
                customer = customer_info['customer']
                
                customer_orders = shipping_data[
                    (shipping_data['‰∫ßÂìÅ‰ª£Á†Å'] == product) &
                    (shipping_data['ÂÆ¢Êà∑‰ª£Á†Å'] == customer)
                ]
                
                if not customer_orders.empty:
                    last_order_date = customer_orders['ËÆ¢ÂçïÊó•Êúü'].max()
                    months_inactive = (current_date - last_order_date).days // 30
                    
                    activity_status[product][customer] = {
                        'last_order_date': last_order_date,
                        'months_inactive': months_inactive,
                        'is_active': months_inactive < self.months_threshold,
                        'contribution': customer_info['contribution']
                    }
                else:
                    activity_status[product][customer] = {
                        'last_order_date': None,
                        'months_inactive': float('inf'),
                        'is_active': False,
                        'contribution': customer_info['contribution']
                    }
        
        return activity_status

# ==================== Êï∞ÊçÆËøΩË∏™Âô® ====================
class DataTracker:
    """Êï∞ÊçÆËøΩË∏™Âô®"""
    def __init__(self, results_file='sales_forecast_results.xlsx'):
        self.results_file = results_file
        self.last_processed_date = None
        self.predictions = {}
        self.actual_sales = {}
        self.accuracy_history = {}
        self.model_params = {}
        self.product_groups = {}
        self.production_decisions = {}
        self.model_accuracy_history = {}
        self.model_predictions = {}
        self.model_selections = {}
        self._load_data()
    
    def _load_data(self):
        """Âä†ËΩΩÂéÜÂè≤Êï∞ÊçÆ"""
        try:
            if os.path.exists(self.results_file):
                # ËøôÈáåÁÆÄÂåñÔºåÂÆûÈôÖÂ∫îËØ•‰ªéExcelËØªÂèñ
                pass
        except Exception as e:
            log(f"Âä†ËΩΩÂéÜÂè≤Êï∞ÊçÆÂ§±Ë¥•: {e}")
        
        # ÂàùÂßãÂåñÈªòËÆ§ÂèÇÊï∞
        self.model_params['default'] = {
            'weights': [0.2, 0.3, 0.5],
            'seasonal_factor': 1.0,
            'promotion_factor': 1.2,
            'safety_stock_factor': 0.5,
            'best_accuracy': 0.0,
        }
    
    def get_params(self, product_code):
        """Ëé∑Âèñ‰∫ßÂìÅÂèÇÊï∞"""
        if product_code not in self.model_params:
            if product_code in self.product_groups:
                group_type = self.product_groups[product_code]
                product_grouper = ProductGrouper()
                params = {
                    'weights': [0.2, 0.3, 0.5],
                    'seasonal_factor': 1.0,
                    'promotion_factor': 1.2,
                    'safety_stock_factor': 0.5,
                    'best_accuracy': 0.0
                }
                if group_type == 'volatile':
                    params['weights'] = [0.1, 0.2, 0.7]
                    params['safety_stock_factor'] = 0.7
                elif group_type == 'seasonal':
                    params['weights'] = [0.15, 0.25, 0.6]
                    params['safety_stock_factor'] = 0.6
                self.model_params[product_code] = params
            else:
                self.model_params[product_code] = self.model_params['default'].copy()
        
        return self.model_params[product_code]
    
    def set_product_group(self, product_code, group_type):
        """ËÆæÁΩÆ‰∫ßÂìÅÂàÜÁªÑ"""
        self.product_groups[product_code] = group_type
    
    def get_product_group(self, product_code):
        """Ëé∑Âèñ‰∫ßÂìÅÂàÜÁªÑ"""
        return self.product_groups.get(product_code, 'stable')
    
    def get_average_accuracy(self, product_code):
        """Ëé∑ÂèñÂπ≥ÂùáÂáÜÁ°ÆÁéá"""
        if product_code not in self.accuracy_history or not self.accuracy_history[product_code]:
            return None
        
        accuracies = [record['accuracy'] for record in self.accuracy_history[product_code]]
        return sum(accuracies) / len(accuracies)
    
    def record_prediction(self, product_code, month, predicted_value):
        """ËÆ∞ÂΩïÈ¢ÑÊµãÂÄº"""
        if product_code not in self.predictions:
            self.predictions[product_code] = {}
        self.predictions[product_code][month] = predicted_value
    
    def record_actual_sales(self, product_code, month, actual_value):
        """ËÆ∞ÂΩïÂÆûÈôÖÈîÄÈáè"""
        if product_code not in self.actual_sales:
            self.actual_sales[product_code] = {}
        self.actual_sales[product_code][month] = actual_value
    
    def save_data(self):
        """‰øùÂ≠òÊï∞ÊçÆÔºàÁÆÄÂåñÁâàÔºâ"""
        log("Êï∞ÊçÆÂ∑≤‰øùÂ≠ò")
        return True

# ==================== ÈîÄÂîÆÈ¢ÑÊµãÂô® ====================
class SalesPredictor:
    """ÈîÄÂîÆÈ¢ÑÊµãÂô®"""
    def __init__(self, shipping_data, product_info, promotion_data, data_tracker=None):
        self.shipping_data = shipping_data
        self.product_info = product_info
        self.promotion_data = promotion_data
        self.current_date = datetime.now()
        self.data_tracker = data_tracker
        
        self.data_preprocessor = DataPreprocessor()
        self.product_grouper = ProductGrouper()
        
        self.special_periods = {
            'ÂÑøÁ´•ËäÇ': (5, 7),
            'ÊöëÂÅá': (7, 9),
            'Êò•ËäÇ': (1, 3)
        }
        
        self.customer_analyzer = CustomerProductAnalyzer()
        self.activity_monitor = CustomerActivityMonitor(months_threshold=3)
    
    def predict_next_months(self, months=4):
        """È¢ÑÊµãÊú™Êù•Âá†‰∏™ÊúàÁöÑÈîÄÈáè"""
        monthly_sales = self._get_monthly_sales()
        
        log("ÂºÄÂßãÊâßË°åÈ¢ÑÊµãÔºå‰ΩøÁî®Áªü‰∏ÄXGBoostÈ¢ÑÊµãÁ≠ñÁï•...")
        
        all_products = self.product_info['‰∫ßÂìÅ‰ª£Á†Å'].unique() if self.product_info is not None else monthly_sales['‰∫ßÂìÅ‰ª£Á†Å'].unique()
        
        log(f"ÂÖ±Êúâ{len(all_products)}‰∏™‰∫ßÂìÅÈúÄË¶ÅÈ¢ÑÊµã")
        
        product_groups = self.product_grouper.group_products(self.shipping_data, all_products)
        
        if self.data_tracker:
            for product, group_type in product_groups.items():
                self.data_tracker.set_product_group(product, group_type)
        
        ml_predictor = MLPredictor(
            self.shipping_data,
            self.product_info,
            self.promotion_data,
            self.data_tracker
        )
        
        predictions = []
        
        current_month = self.current_date.month
        current_year = self.current_date.year
        
        log("ÂºÄÂßãÂØπÂêÑ‰∫ßÂìÅËøõË°åÈ¢ÑÊµã...")
        
        for product in all_products:
            product_group = self.data_tracker.get_product_group(product) if self.data_tracker else 'stable'
            
            product_data = monthly_sales[monthly_sales['‰∫ßÂìÅ‰ª£Á†Å'] == product]
            data_months = len(product_data['Êúà‰ªΩ'].unique())
            is_new_product = data_months < 6
            
            log(f"‰∫ßÂìÅ {product}: ‰ΩøÁî®Áªü‰∏ÄXGBoostÈ¢ÑÊµã (Êï∞ÊçÆÊúàÊï∞: {data_months}, ÂàÜÁªÑ: {product_group})")
            ml_predictions = ml_predictor.predict_next_months(product, months, self.current_date)
            
            for i in range(months):
                if ml_predictions is not None and i < len(ml_predictions):
                    predict_month = current_month + i
                    predict_year = current_year
                    if predict_month > 12:
                        predict_month -= 12
                        predict_year += 1
                    
                    month_str = f"{predict_year}-{predict_month:02d}"
                    
                    product_name = ''
                    if self.product_info is not None:
                        product_info = self.product_info[self.product_info['‰∫ßÂìÅ‰ª£Á†Å'] == product]
                        if not product_info.empty:
                            product_name = product_info.iloc[0]['‰∫ßÂìÅÂêçÁß∞']
                    
                    ml_pred = ml_predictions[i]
                    
                    prediction_item = {
                        '‰∫ßÂìÅ‰ª£Á†Å': product,
                        '‰∫ßÂìÅÂêçÁß∞': product_name,
                        'È¢ÑÊµãÊúà‰ªΩ': month_str,
                        'È¢ÑÊµãÈîÄÈáè': ml_pred,
                        'Â≠£ËäÇÊÄßÂõ†Â≠ê': 1.0,
                        '‰øÉÈîÄÂõ†Â≠ê': 1.0,
                        '‰øùÂÆàÁ≥ªÊï∞': 0.95 if not is_new_product else 0.9
                    }
                    
                    predictions.append(prediction_item)
                    
                    if self.data_tracker:
                        self.data_tracker.record_prediction(product, month_str, ml_pred)
        
        if self.data_tracker:
            self.data_tracker.save_data()
        
        log(f"È¢ÑÊµãÂÆåÊàê: Â∑≤È¢ÑÊµã {len(all_products)} ‰∏™‰∫ßÂìÅÁöÑ {months} ‰∏™ÊúàÈîÄÈáè")
        
        return pd.DataFrame(predictions)
    
    def _get_monthly_sales(self):
        """Ëé∑ÂèñÊúàÂ∫¶ÈîÄÈáè"""
        monthly_sales = self.shipping_data.copy()
        monthly_sales['Êúà‰ªΩ'] = monthly_sales['ËÆ¢ÂçïÊó•Êúü'].dt.to_period('M')
        monthly_sales = monthly_sales.groupby(['Êúà‰ªΩ', '‰∫ßÂìÅ‰ª£Á†Å'])['Ê±ÇÂíåÈ°π:Êï∞ÈáèÔºàÁÆ±Ôºâ'].sum().reset_index()
        return monthly_sales

# ==================== Â∫ìÂ≠òÁÆ°ÁêÜÂô® ====================
class InventoryManager:
    """Â∫ìÂ≠òÁÆ°ÁêÜÂô®"""
    def __init__(self, inventory_data, product_info, shipping_data, data_tracker=None, batch_data=None):
        self.inventory_data = inventory_data
        self.product_info = product_info
        self.shipping_data = shipping_data
        self.batch_data = batch_data
        self.current_date = datetime.now()
        self.data_tracker = data_tracker
    
    def calculate_safety_stock(self):
        """ËÆ°ÁÆóÂÆâÂÖ®Â∫ìÂ≠ò"""
        if self.shipping_data is None:
            return pd.DataFrame()
        
        six_months_ago = self.current_date - timedelta(days=180)
        six_month_sales = self.shipping_data[self.shipping_data['ËÆ¢ÂçïÊó•Êúü'] >= six_months_ago]
        monthly_sales = six_month_sales.groupby('‰∫ßÂìÅ‰ª£Á†Å')['Ê±ÇÂíåÈ°π:Êï∞ÈáèÔºàÁÆ±Ôºâ'].sum() / 6
        
        safety_stock = pd.DataFrame({
            '‰∫ßÂìÅ‰ª£Á†Å': monthly_sales.index,
            'ÊúàÂùáÈîÄÈáè': monthly_sales.values.round()
        })
        
        safety_stock['ÂÆâÂÖ®Â∫ìÂ≠ò'] = safety_stock.apply(
            lambda row: round(row['ÊúàÂùáÈîÄÈáè'] * 
                              (self.data_tracker.get_params(row['‰∫ßÂìÅ‰ª£Á†Å'])['safety_stock_factor'] if self.data_tracker else 0.5)),
            axis=1
        )
        
        if self.product_info is not None:
            safety_stock = safety_stock.merge(
                self.product_info[['‰∫ßÂìÅ‰ª£Á†Å', '‰∫ßÂìÅÂêçÁß∞']],
                on='‰∫ßÂìÅ‰ª£Á†Å', how='left'
            )
        
        return safety_stock
    
    def identify_stock_issues(self, sales_prediction):
        """ËØÜÂà´Â∫ìÂ≠òÈóÆÈ¢ò"""
        if self.inventory_data is None:
            return pd.DataFrame(), pd.DataFrame(), pd.DataFrame()
        
        batch_info_by_product = {}
        
        if self.batch_data is not None and not self.batch_data.empty:
            for _, row in self.batch_data.iterrows():
                product_code = row['Áâ©Êñô']
                production_date = row['Áîü‰∫ßÊó•Êúü']
                quantity = row['Êï∞Èáè']
                
                if pd.notna(production_date):
                    age_days = (self.current_date - production_date).days
                    
                    if (product_code not in batch_info_by_product or
                            age_days > batch_info_by_product[product_code]['age']):
                        
                        product_name = ''
                        if self.product_info is not None:
                            product_info = self.product_info[self.product_info['‰∫ßÂìÅ‰ª£Á†Å'] == product_code]
                            if not product_info.empty:
                                product_name = product_info.iloc[0]['‰∫ßÂìÅÂêçÁß∞']
                        
                        batch_info_by_product[product_code] = {
                            'product_name': product_name,
                            'date': production_date,
                            'age': age_days,
                            'quantity': quantity,
                            'is_backlog': age_days > 90
                        }
        
        batch_info = []
        backlog_products = []
        
        for _, row in self.inventory_data.iterrows():
            product_code = row['Áâ©Êñô']
            product_name = ''
            
            if self.product_info is not None:
                product_info = self.product_info[self.product_info['‰∫ßÂìÅ‰ª£Á†Å'] == product_code]
                if not product_info.empty:
                    product_name = product_info.iloc[0]['‰∫ßÂìÅÂêçÁß∞']
            
            if product_code in batch_info_by_product:
                info = batch_info_by_product[product_code]
                batch_record = {
                    '‰∫ßÂìÅ‰ª£Á†Å': product_code,
                    '‰∫ßÂìÅÂêçÁß∞': product_name,
                    'Áîü‰∫ßÊó•Êúü': info['date'],
                    'ÊâπÊ¨°Âπ¥ÈæÑ(Â§©)': info['age'],
                    'Êï∞Èáè': info['quantity']
                }
                batch_info.append(batch_record)
                
                if info['is_backlog']:
                    backlog_record = batch_record.copy()
                    backlog_record['ÁßØÂéãÊï∞Èáè'] = backlog_record.pop('Êï∞Èáè')
                    backlog_products.append(backlog_record)
            else:
                batch_info.append({
                    '‰∫ßÂìÅ‰ª£Á†Å': product_code,
                    '‰∫ßÂìÅÂêçÁß∞': product_name,
                    'Áîü‰∫ßÊó•Êúü': None,
                    'ÊâπÊ¨°Âπ¥ÈæÑ(Â§©)': 0,
                    'Êï∞Èáè': 0
                })
        
        stockout_risk = []
        
        current_stock = self.inventory_data[['Áâ©Êñô', 'Áé∞ÊúâÂ∫ìÂ≠ò']].copy()
        current_stock.rename(columns={'Áâ©Êñô': '‰∫ßÂìÅ‰ª£Á†Å'}, inplace=True)
        
        if not sales_prediction.empty:
            prediction_monthly = sales_prediction.groupby('‰∫ßÂìÅ‰ª£Á†Å')['È¢ÑÊµãÈîÄÈáè'].mean().reset_index()
            prediction_monthly['15Â§©ÈîÄÈáè'] = (prediction_monthly['È¢ÑÊµãÈîÄÈáè'] / 30 * 15).round()
            
            stock_vs_prediction = current_stock.merge(
                prediction_monthly[['‰∫ßÂìÅ‰ª£Á†Å', '15Â§©ÈîÄÈáè']],
                on='‰∫ßÂìÅ‰ª£Á†Å', how='outer'
            ).fillna(0)
            
            for _, row in stock_vs_prediction.iterrows():
                if row['Áé∞ÊúâÂ∫ìÂ≠ò'] < row['15Â§©ÈîÄÈáè']:
                    product_code = row['‰∫ßÂìÅ‰ª£Á†Å']
                    product_name = ''
                    if self.product_info is not None:
                        product_info = self.product_info[self.product_info['‰∫ßÂìÅ‰ª£Á†Å'] == product_code]
                        if not product_info.empty:
                            product_name = product_info.iloc[0]['‰∫ßÂìÅÂêçÁß∞']
                    
                    stockout_risk.append({
                        '‰∫ßÂìÅ‰ª£Á†Å': product_code,
                        '‰∫ßÂìÅÂêçÁß∞': product_name,
                        'ÂΩìÂâçÂ∫ìÂ≠ò': row['Áé∞ÊúâÂ∫ìÂ≠ò'],
                        '15Â§©È¢ÑÊµãÈîÄÈáè': row['15Â§©ÈîÄÈáè'],
                        'Áº∫Ë¥ßÈ£éÈô©': 'È´ò' if row['Áé∞ÊúâÂ∫ìÂ≠ò'] < row['15Â§©ÈîÄÈáè'] / 2 else '‰∏≠'
                    })
        
        return pd.DataFrame(backlog_products), pd.DataFrame(stockout_risk), pd.DataFrame(batch_info)

# ==================== Áîü‰∫ßËÆ°ÂàíÂô® ====================
class ProductionPlanner:
    """Áîü‰∫ßËÆ°ÂàíÂô®"""
    def __init__(self, inventory_data, sales_prediction, safety_stock):
        self.inventory_data = inventory_data
        self.sales_prediction = sales_prediction
        self.safety_stock = safety_stock
    
    def generate_production_plan(self, batch_info=None, data_tracker=None):
        """ÁîüÊàêÁîü‰∫ßËÆ°Âàí"""
        if self.inventory_data is None or self.sales_prediction is None or self.safety_stock is None:
            return pd.DataFrame()
        
        current_stock = self.inventory_data[['Áâ©Êñô', 'Áé∞ÊúâÂ∫ìÂ≠ò']].copy()
        current_stock.rename(columns={'Áâ©Êñô': '‰∫ßÂìÅ‰ª£Á†Å'}, inplace=True)
        
        all_months = self.sales_prediction['È¢ÑÊµãÊúà‰ªΩ'].unique()
        months_sorted = sorted(all_months)
        
        all_plans = []
        
        for i, month in enumerate(months_sorted):
            month_forecast = self.sales_prediction[self.sales_prediction['È¢ÑÊµãÊúà‰ªΩ'] == month]
            
            month_plan = current_stock.copy()
            month_plan['Êúà‰ªΩ'] = month
            
            month_plan = month_plan.merge(
                month_forecast[['‰∫ßÂìÅ‰ª£Á†Å', 'È¢ÑÊµãÈîÄÈáè']],
                on='‰∫ßÂìÅ‰ª£Á†Å', how='left'
            ).fillna(0)
            
            month_plan = month_plan.merge(
                self.safety_stock[['‰∫ßÂìÅ‰ª£Á†Å', 'ÂÆâÂÖ®Â∫ìÂ≠ò', 'ÊúàÂùáÈîÄÈáè']],
                on='‰∫ßÂìÅ‰ª£Á†Å', how='left'
            ).fillna(0)
            
            if '‰∫ßÂìÅÂêçÁß∞' in self.safety_stock.columns:
                month_plan = month_plan.merge(
                    self.safety_stock[['‰∫ßÂìÅ‰ª£Á†Å', '‰∫ßÂìÅÂêçÁß∞']],
                    on='‰∫ßÂìÅ‰ª£Á†Å', how='left'
                )
            
            month_plan['Êó•ÂùáÈîÄÈáè'] = month_plan['ÊúàÂùáÈîÄÈáè'] / 30
            month_plan['Â∫ìÂ≠òË¶ÜÁõñÂ§©Êï∞'] = month_plan.apply(
                lambda row: round(row['Áé∞ÊúâÂ∫ìÂ≠ò'] / row['Êó•ÂùáÈîÄÈáè']) if row['Êó•ÂùáÈîÄÈáè'] > 0 else 0,
                axis=1
            )
            
            if i == 0:
                month_plan['ÈúÄË¶ÅÁîü‰∫ßÊï∞Èáè'] = month_plan.apply(
                    lambda row: max(0, round(
                        row['È¢ÑÊµãÈîÄÈáè'] - row['Áé∞ÊúâÂ∫ìÂ≠ò'] + row['ÂÆâÂÖ®Â∫ìÂ≠ò'] * 1.2
                    )),
                    axis=1
                )
            elif i == 1:
                prev_month_plan = all_plans[0].copy()
                
                month_plan['È¢ÑËÆ°Ââ©‰ΩôÂ∫ìÂ≠ò'] = month_plan.apply(
                    lambda row: max(0, row['Áé∞ÊúâÂ∫ìÂ≠ò'] -
                                    prev_month_plan.loc[
                                        prev_month_plan['‰∫ßÂìÅ‰ª£Á†Å'] == row['‰∫ßÂìÅ‰ª£Á†Å'],
                                        'È¢ÑÊµãÈîÄÈáè'
                                    ].sum() +
                                    prev_month_plan.loc[
                                        prev_month_plan['‰∫ßÂìÅ‰ª£Á†Å'] == row['‰∫ßÂìÅ‰ª£Á†Å'],
                                        'ÈúÄË¶ÅÁîü‰∫ßÊï∞Èáè'
                                    ].sum()),
                    axis=1
                )
                
                month_plan['ÈúÄË¶ÅÁîü‰∫ßÊï∞Èáè'] = month_plan.apply(
                    lambda row: max(0, round(
                        row['È¢ÑÊµãÈîÄÈáè'] - row['È¢ÑËÆ°Ââ©‰ΩôÂ∫ìÂ≠ò'] + row['ÂÆâÂÖ®Â∫ìÂ≠ò']
                    )),
                    axis=1
                )
            else:
                prev_month_plan1 = all_plans[0].copy()
                prev_month_plan2 = all_plans[1].copy()
                
                month_plan['È¢ÑËÆ°Ââ©‰ΩôÂ∫ìÂ≠ò'] = month_plan.apply(
                    lambda row: max(0, row['Áé∞ÊúâÂ∫ìÂ≠ò'] -
                                    prev_month_plan1.loc[
                                        prev_month_plan1['‰∫ßÂìÅ‰ª£Á†Å'] == row['‰∫ßÂìÅ‰ª£Á†Å'],
                                        'È¢ÑÊµãÈîÄÈáè'
                                    ].sum() -
                                    prev_month_plan2.loc[
                                        prev_month_plan2['‰∫ßÂìÅ‰ª£Á†Å'] == row['‰∫ßÂìÅ‰ª£Á†Å'],
                                        'È¢ÑÊµãÈîÄÈáè'
                                    ].sum() +
                                    prev_month_plan1.loc[
                                        prev_month_plan1['‰∫ßÂìÅ‰ª£Á†Å'] == row['‰∫ßÂìÅ‰ª£Á†Å'],
                                        'ÈúÄË¶ÅÁîü‰∫ßÊï∞Èáè'
                                    ].sum() +
                                    prev_month_plan2.loc[
                                        prev_month_plan2['‰∫ßÂìÅ‰ª£Á†Å'] == row['‰∫ßÂìÅ‰ª£Á†Å'],
                                        'ÈúÄË¶ÅÁîü‰∫ßÊï∞Èáè'
                                    ].sum()),
                    axis=1
                )
                
                month_plan['ÈúÄË¶ÅÁîü‰∫ßÊï∞Èáè'] = month_plan.apply(
                    lambda row: max(0, round(
                        row['È¢ÑÊµãÈîÄÈáè'] - row['È¢ÑËÆ°Ââ©‰ΩôÂ∫ìÂ≠ò'] + row['ÂÆâÂÖ®Â∫ìÂ≠ò'] * 0.8
                    )),
                    axis=1
                )
            
            month_plan['‰ºòÂÖàÁ∫ßÂàÜÊï∞'] = month_plan.apply(
                lambda row: 0 if row['Áé∞ÊúâÂ∫ìÂ≠ò'] == 0 else row['Â∫ìÂ≠òË¶ÜÁõñÂ§©Êï∞'],
                axis=1
            )
            
            month_plan['Êéí‰∫ß‰ºòÂÖàÁ∫ß'] = month_plan['‰ºòÂÖàÁ∫ßÂàÜÊï∞'].rank()
            
            all_plans.append(month_plan)
        
        production_plan = pd.concat(all_plans, ignore_index=True)
        
        if batch_info is not None and data_tracker is not None:
            for product_code in production_plan['‰∫ßÂìÅ‰ª£Á†Å'].unique():
                product_batch = batch_info[batch_info['‰∫ßÂìÅ‰ª£Á†Å'] == product_code]
                if not product_batch.empty and 'ÊâπÊ¨°Âπ¥ÈæÑ(Â§©)' in product_batch.columns:
                    batch_age = product_batch['ÊâπÊ¨°Âπ¥ÈæÑ(Â§©)'].max()
                    if pd.notna(batch_age) and batch_age > 0:
                        # ËøôÈáåÂèØ‰ª•Ê†πÊçÆÊâπÊ¨°Âπ¥ÈæÑË∞ÉÊï¥ÂèÇÊï∞
                        pass
        
        production_plan = production_plan[production_plan['ÈúÄË¶ÅÁîü‰∫ßÊï∞Èáè'] > 0]
        production_plan = production_plan.sort_values(['Êúà‰ªΩ', 'Êéí‰∫ß‰ºòÂÖàÁ∫ß'])
        
        return production_plan

# ==================== ÁºìÂ≠òÊï∞ÊçÆÂä†ËΩΩÂáΩÊï∞ ====================
@st.cache_data(ttl=3600)
def load_github_data(file_url):
    """‰ªéGitHubÂä†ËΩΩExcelÊñá‰ª∂"""
    try:
        response = requests.get(file_url)
        if response.status_code == 200:
            return pd.read_excel(BytesIO(response.content))
        else:
            st.error(f"Êó†Ê≥ïÂä†ËΩΩÊñá‰ª∂: {file_url}")
            return None
    except Exception as e:
        st.error(f"Âä†ËΩΩÊï∞ÊçÆÂá∫Èîô: {str(e)}")
        return None

# ==================== Êï∞ÊçÆÂä†ËΩΩÂô® ====================
class DataLoader:
    """Êï∞ÊçÆÂä†ËΩΩÂô®"""
    def __init__(self):
        self.shipping_data = None
        self.inventory_data = None
        self.batch_data = None
        self.product_info = None
        self.promotion_data = None
    
    def load_all_data(self):
        """Âä†ËΩΩÊâÄÊúâÊï∞ÊçÆ"""
        base_url = "https://raw.githubusercontent.com/CIRA18-HUB/sales_dashboard/main/"
        
        data = {}
        files = {
            'shipping': 'È¢ÑÊµãÊ®°ÂûãÂá∫Ë¥ßÊï∞ÊçÆÊØèÊó•xlsx.xlsx',
            'inventory': 'Âê´ÊâπÊ¨°Â∫ìÂ≠ò0221(2).xlsx', 
            'product': '‰∫ßÂìÅ‰ø°ÊÅØ.xlsx',
            'promotion': 'ÈîÄÂîÆ‰∏öÂä°Âëò‰øÉÈîÄÊñá‰ª∂.xlsx'
        }
        
        for key, filename in files.items():
            with st.spinner(f'Âä†ËΩΩ{filename}...'):
                data[key] = load_github_data(base_url + filename)
        
        # Â§ÑÁêÜÊï∞ÊçÆ
        if data['shipping'] is not None:
            self.shipping_data = data['shipping']
            self.shipping_data['ËÆ¢ÂçïÊó•Êúü'] = pd.to_datetime(self.shipping_data['ËÆ¢ÂçïÊó•Êúü'])
            
        if data['inventory'] is not None:
            self.inventory_data = data['inventory']
            # Â§ÑÁêÜÊâπÊ¨°Êï∞ÊçÆ
            self._process_batch_data(data['inventory'])
            
        if data['product'] is not None:
            self.product_info = data['product']
            # Ê∏ÖÁêÜ‰∫ßÂìÅÂêçÁß∞
            if '‰∫ßÂìÅÂêçÁß∞' in self.product_info.columns:
                self.product_info['‰∫ßÂìÅÂêçÁß∞'] = self.product_info['‰∫ßÂìÅÂêçÁß∞'].apply(self._clean_product_name)
        
        if data['promotion'] is not None:
            self.promotion_data = data['promotion']
        
        return self
    
    def _process_batch_data(self, raw_data):
        """Â§ÑÁêÜÊâπÊ¨°Êï∞ÊçÆ"""
        batch_data = []
        inventory_data = []
        
        current_product = None
        
        for idx, row in raw_data.iterrows():
            if pd.notna(row.get('Áâ©Êñô')):
                product_code = row['Áâ©Êñô']
                current_product = {
                    'Áâ©Êñô': product_code,
                    'ÊèèËø∞': row.get('ÊèèËø∞', ''),
                    'Áé∞ÊúâÂ∫ìÂ≠ò': row.get('Áé∞ÊúâÂ∫ìÂ≠ò', 0)
                }
                inventory_data.append(current_product)
            
            elif pd.notna(row.get('Â∫ì‰Ωç')) and current_product is not None:
                product_code = current_product['Áâ©Êñô']
                batch_record = {
                    'Áâ©Êñô': product_code,
                    'Â∫ì‰Ωç': row.get('Â∫ì‰Ωç', ''),
                    'Áîü‰∫ßÊó•Êúü': row.get('Áîü‰∫ßÊó•Êúü'),
                    'Áîü‰∫ßÊâπÂè∑': row.get('Áîü‰∫ßÊâπÂè∑', ''),
                    'Êï∞Èáè': row.get('Êï∞Èáè', 0)
                }
                batch_data.append(batch_record)
        
        self.inventory_data = pd.DataFrame(inventory_data)
        self.batch_data = pd.DataFrame(batch_data)
        
        if not self.batch_data.empty and 'Áîü‰∫ßÊó•Êúü' in self.batch_data.columns:
            self.batch_data['Áîü‰∫ßÊó•Êúü'] = pd.to_datetime(self.batch_data['Áîü‰∫ßÊó•Êúü'], errors='coerce')
    
    def _clean_product_name(self, name):
        """Ê∏ÖÁêÜ‰∫ßÂìÅÂêçÁß∞"""
        if pd.isna(name):
            return name
        name = str(name)
        name = name.replace('Âè£Âäõ', '')
        name = name.replace('-‰∏≠ÂõΩ', '')
        return name.strip()

# ==================== Á≥ªÁªüÁ±ª ====================
class SalesForecastSystem:
    """ÈîÄÂîÆÈ¢ÑÊµãÁ≥ªÁªü"""
    def __init__(self):
        self.data_loader = DataLoader()
        self.data_tracker = DataTracker()
        self.sales_predictor = None
        self.inventory_manager = None
        self.production_planner = None
    
    def load_data(self):
        """Âä†ËΩΩÊï∞ÊçÆ"""
        self.data_loader.load_all_data()
        return True
    
    def run_forecast(self, months=4):
        """ËøêË°åÈ¢ÑÊµã"""
        # ÂàõÂª∫ÈîÄÂîÆÈ¢ÑÊµãÂô®
        self.sales_predictor = SalesPredictor(
            self.data_loader.shipping_data,
            self.data_loader.product_info,
            self.data_loader.promotion_data,
            self.data_tracker
        )
        
        # ÊâßË°åÈ¢ÑÊµã
        sales_prediction = self.sales_predictor.predict_next_months(months)
        
        # ÂàõÂª∫Â∫ìÂ≠òÁÆ°ÁêÜÂô®
        self.inventory_manager = InventoryManager(
            self.data_loader.inventory_data,
            self.data_loader.product_info,
            self.data_loader.shipping_data,
            self.data_tracker,
            self.data_loader.batch_data
        )
        
        # ËÆ°ÁÆóÂÆâÂÖ®Â∫ìÂ≠ò
        safety_stock = self.inventory_manager.calculate_safety_stock()
        
        # ËØÜÂà´Â∫ìÂ≠òÈóÆÈ¢ò
        backlog_products, stockout_risk, batch_info = self.inventory_manager.identify_stock_issues(sales_prediction)
        
        # ÂàõÂª∫Áîü‰∫ßËÆ°ÂàíÂô®
        self.production_planner = ProductionPlanner(
            self.data_loader.inventory_data,
            sales_prediction,
            safety_stock
        )
        
        # ÁîüÊàêÁîü‰∫ßËÆ°Âàí
        production_plan = self.production_planner.generate_production_plan(batch_info, self.data_tracker)
        
        return {
            'sales_prediction': sales_prediction,
            'production_plan': production_plan,
            'backlog_products': backlog_products,
            'stockout_risk': stockout_risk,
            'batch_info': batch_info,
            'safety_stock': safety_stock
        }

# ==================== ËæÖÂä©ÂáΩÊï∞ ====================
def format_amount(amount):
    """Ê†ºÂºèÂåñÈáëÈ¢ù"""
    if amount >= 100000000:
        return f"¬•{amount / 100000000:.1f}‰∫ø"
    elif amount >= 10000:
        return f"¬•{amount / 10000:.0f}‰∏á"
    else:
        return f"¬•{amount:,.0f}"

def create_analysis_charts(system):
    """ÂàõÂª∫ÂàÜÊûêÂõæË°®"""
    charts = {}
    
    # 1. ÈîÄÂîÆË∂ãÂäøÂõæ
    if system.data_loader.shipping_data is not None:
        monthly_sales = system.data_loader.shipping_data.copy()
        monthly_sales['Êúà‰ªΩ'] = pd.to_datetime(monthly_sales['ËÆ¢ÂçïÊó•Êúü']).dt.to_period('M')
        monthly_trend = monthly_sales.groupby('Êúà‰ªΩ')['Ê±ÇÂíåÈ°π:Êï∞ÈáèÔºàÁÆ±Ôºâ'].sum().reset_index()
        monthly_trend['Êúà‰ªΩ'] = monthly_trend['Êúà‰ªΩ'].dt.to_timestamp()
        
        fig_trend = go.Figure()
        fig_trend.add_trace(go.Scatter(
            x=monthly_trend['Êúà‰ªΩ'],
            y=monthly_trend['Ê±ÇÂíåÈ°π:Êï∞ÈáèÔºàÁÆ±Ôºâ'],
            mode='lines+markers',
            name='ÂÆûÈôÖÈîÄÈáè',
            line=dict(width=3, color='#667eea'),
            marker=dict(size=8)
        ))
        
        fig_trend.update_layout(
            title="ÂéÜÂè≤ÈîÄÂîÆË∂ãÂäø",
            xaxis_title="Êúà‰ªΩ",
            yaxis_title="ÈîÄÈáèÔºàÁÆ±Ôºâ",
            height=400,
            plot_bgcolor='white',
            paper_bgcolor='white'
        )
        charts['sales_trend'] = fig_trend
    
    # 2. ‰∫ßÂìÅÂàÜÁªÑÂàÜÂ∏É
    grouper = ProductGrouper()
    if system.data_loader.shipping_data is not None:
        product_groups = grouper.group_products(system.data_loader.shipping_data)
        group_counts = pd.Series(product_groups).value_counts()
        
        fig_groups = go.Figure(data=[
            go.Pie(
                labels=group_counts.index,
                values=group_counts.values,
                hole=0.4,
                marker_colors=['#667eea', '#764ba2', '#ff6b6b']
            )
        ])
        
        fig_groups.update_layout(
            title="‰∫ßÂìÅÂàÜÁªÑÂàÜÂ∏É",
            height=400,
            plot_bgcolor='white',
            paper_bgcolor='white'
        )
        charts['product_groups'] = fig_groups
    
    return charts

# ==================== ‰∏ªÁïåÈù¢ ====================
st.markdown("""
<div class="main-header">
    <h1>ü§ñ Êú∫Âô®Â≠¶‰π†È¢ÑÊµãÊéí‰∫ßÊô∫ËÉΩÁ≥ªÁªü</h1>
    <p>Âü∫‰∫éXGBoostÁöÑÂ§öÊ®°ÂûãËûçÂêàÈ¢ÑÊµã</p>
</div>
""", unsafe_allow_html=True)

# ‰æßËæπÊ†èÊéßÂà∂
with st.sidebar:
    st.header("ÊéßÂà∂Èù¢Êùø")
    
    if st.button("üîÑ Âà∑Êñ∞Êï∞ÊçÆ", type="primary"):
        st.cache_data.clear()
        st.rerun()
    
    st.subheader("È¢ÑÊµãÂèÇÊï∞")
    prediction_months = st.slider("È¢ÑÊµãÊúàÊï∞", 1, 6, 4)
    
    st.subheader("ÊòæÁ§∫ÈÄâÈ°π")
    show_accuracy = st.checkbox("ÊòæÁ§∫ÂáÜÁ°ÆÁéáÂàÜÊûê", value=True)
    show_customer = st.checkbox("ÊòæÁ§∫ÂÆ¢Êà∑ÂàÜÊûê", value=True)
    show_batch = st.checkbox("ÊòæÁ§∫ÊâπÊ¨°ÂàÜÊûê", value=True)

# ÂàùÂßãÂåñÁ≥ªÁªü
@st.cache_resource
def init_system():
    system = SalesForecastSystem()
    system.load_data()
    return system

# ‰∏ªË¶ÅÂÜÖÂÆπÂå∫Âüü
try:
    # Âä†ËΩΩÁ≥ªÁªü
    with st.spinner('ÂàùÂßãÂåñÁ≥ªÁªü...'):
        system = init_system()
    
    if system.data_loader.shipping_data is not None:
        # Ëé∑ÂèñÂü∫Á°ÄÁªüËÆ°‰ø°ÊÅØ
        total_products = len(system.data_loader.shipping_data['‰∫ßÂìÅ‰ª£Á†Å'].unique())
        total_customers = len(system.data_loader.shipping_data['ÂÆ¢Êà∑‰ª£Á†Å'].unique()) if 'ÂÆ¢Êà∑‰ª£Á†Å' in system.data_loader.shipping_data.columns else 0
        total_inventory_value = system.data_loader.inventory_data['Áé∞ÊúâÂ∫ìÂ≠ò'].sum() * 100 if system.data_loader.inventory_data is not None else 0
        
        # ÂàõÂª∫ÂàÜÊûêÂõæË°®
        charts = create_analysis_charts(system)
        
        # ÂàõÂª∫Ê†áÁ≠æÈ°µ
        tabs = st.tabs([
            "üìä Êï∞ÊçÆÊ¶ÇËßà", "üß† Ê®°ÂûãÈ¢ÑÊµãÂàÜÊûê", "üìà ÂáÜÁ°ÆÁéáÂàÜÊûê", 
            "üì¶ Â∫ìÂ≠òÁä∂ÊÄÅ", "üìã Êô∫ËÉΩÂª∫ËÆÆ"
        ])
        
        # Tab 1: Êï∞ÊçÆÊ¶ÇËßà
        with tabs[0]:
            st.markdown("### üìä Á≥ªÁªüÊï∞ÊçÆÊ¶ÇËßà")
            
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                st.markdown(f"""
                <div class="metric-card">
                    <div class="metric-value">{total_products}</div>
                    <div class="metric-label">ÊÄª‰∫ßÂìÅÊï∞</div>
                    <div class="metric-sublabel">Ê¥ªË∑ÉSKU</div>
                </div>
                """, unsafe_allow_html=True)
            
            with col2:
                st.markdown(f"""
                <div class="metric-card">
                    <div class="metric-value">{total_customers}</div>
                    <div class="metric-label">ÂÆ¢Êà∑Êï∞Èáè</div>
                    <div class="metric-sublabel">Ê¥ªË∑ÉÂÆ¢Êà∑</div>
                </div>
                """, unsafe_allow_html=True)
            
            with col3:
                st.markdown(f"""
                <div class="metric-card">
                    <div class="big-value">{format_amount(total_inventory_value)}</div>
                    <div class="metric-label">Â∫ìÂ≠òÊÄªÂÄº</div>
                    <div class="metric-sublabel">ÂΩìÂâçÂ∫ìÂ≠ò</div>
                </div>
                """, unsafe_allow_html=True)
            
            with col4:
                st.markdown(f"""
                <div class="metric-card">
                    <div class="metric-value">{len(system.data_loader.shipping_data)}</div>
                    <div class="metric-label">ËÆ¢ÂçïËÆ∞ÂΩïÊï∞</div>
                    <div class="metric-sublabel">ÂéÜÂè≤Êï∞ÊçÆ</div>
                </div>
                """, unsafe_allow_html=True)
            
            # ÊòæÁ§∫ÂõæË°®
            if 'sales_trend' in charts:
                st.markdown('''
                <div class="chart-header">
                    <div class="chart-title">ÂéÜÂè≤ÈîÄÂîÆË∂ãÂäø</div>
                    <div class="chart-subtitle">ÊúàÂ∫¶ÈîÄÂîÆÊï∞ÊçÆÂàÜÊûê</div>
                </div>
                ''', unsafe_allow_html=True)
                st.plotly_chart(charts['sales_trend'], use_container_width=True)
            
            col1, col2 = st.columns(2)
            with col1:
                if 'product_groups' in charts:
                    st.plotly_chart(charts['product_groups'], use_container_width=True)
            
            with col2:
                # ËøôÈáåÂèØ‰ª•Ê∑ªÂä†ÂÖ∂‰ªñÂõæË°®
                pass
        
        # Tab 2: Ê®°ÂûãÈ¢ÑÊµãÂàÜÊûê
        with tabs[1]:
            st.markdown('''
            <div class="chart-header">
                <div class="chart-title">Â§öÊ®°ÂûãÈ¢ÑÊµãÂàÜÊûê</div>
                <div class="chart-subtitle">Âü∫‰∫éXGBoostÁöÑÊô∫ËÉΩÈ¢ÑÊµã</div>
            </div>
            ''', unsafe_allow_html=True)
            
            # ËøêË°åÈ¢ÑÊµã
            with st.spinner('ËøêË°åÈ¢ÑÊµãÊ®°Âûã...'):
                results = system.run_forecast(prediction_months)
            
            # ÊòæÁ§∫È¢ÑÊµãÁªìÊûú
            if results['sales_prediction'] is not None and not results['sales_prediction'].empty:
                # ÈÄâÊã©‰∫ßÂìÅÊòæÁ§∫ËØ¶ÁªÜÈ¢ÑÊµã
                products = results['sales_prediction']['‰∫ßÂìÅ‰ª£Á†Å'].unique()[:20]
                selected_product = st.selectbox("ÈÄâÊã©‰∫ßÂìÅÊü•ÁúãËØ¶ÁªÜÈ¢ÑÊµã", products)
                
                # Ëé∑ÂèñËØ•‰∫ßÂìÅÁöÑÈ¢ÑÊµãÊï∞ÊçÆ
                product_pred = results['sales_prediction'][results['sales_prediction']['‰∫ßÂìÅ‰ª£Á†Å'] == selected_product]
                
                # ÂàõÂª∫È¢ÑÊµãÂõæË°®
                fig_pred = go.Figure()
                fig_pred.add_trace(go.Scatter(
                    x=product_pred['È¢ÑÊµãÊúà‰ªΩ'],
                    y=product_pred['È¢ÑÊµãÈîÄÈáè'],
                    mode='lines+markers',
                    name='È¢ÑÊµãÈîÄÈáè',
                    line=dict(width=3, color='#667eea'),
                    marker=dict(size=10)
                ))
                
                fig_pred.update_layout(
                    title=f"‰∫ßÂìÅ {selected_product} ÈîÄÈáèÈ¢ÑÊµã",
                    xaxis_title="Êúà‰ªΩ",
                    yaxis_title="È¢ÑÊµãÈîÄÈáèÔºàÁÆ±Ôºâ",
                    height=400,
                    plot_bgcolor='white',
                    paper_bgcolor='white'
                )
                
                st.plotly_chart(fig_pred, use_container_width=True)
                
                # ÊòæÁ§∫È¢ÑÊµãÊï∞ÊçÆË°®
                st.dataframe(product_pred[['È¢ÑÊµãÊúà‰ªΩ', 'È¢ÑÊµãÈîÄÈáè', 'Â≠£ËäÇÊÄßÂõ†Â≠ê', '‰øÉÈîÄÂõ†Â≠ê', '‰øùÂÆàÁ≥ªÊï∞']], 
                            use_container_width=True)
        
        # Tab 3: ÂáÜÁ°ÆÁéáÂàÜÊûê
        with tabs[2]:
            st.markdown('''
            <div class="chart-header">
                <div class="chart-title">È¢ÑÊµãÂáÜÁ°ÆÁéáÂàÜÊûê</div>
                <div class="chart-subtitle">Ê®°ÂûãÊÄßËÉΩËØÑ‰º∞</div>
            </div>
            ''', unsafe_allow_html=True)
            
            if show_accuracy:
                # ËøôÈáåÂèØ‰ª•Ê∑ªÂä†ÂáÜÁ°ÆÁéáÂàÜÊûêÂÜÖÂÆπ
                st.markdown("""
                <div class="insight-card">
                    <h4>üìä ÂáÜÁ°ÆÁéáËØÑ‰º∞ËØ¥Êòé</h4>
                    <ul>
                        <li>‰ΩøÁî®ÂéÜÂè≤Êï∞ÊçÆÊúÄÂêé‰∏Ä‰∏™Êúà‰Ωú‰∏∫ÊµãËØïÈõÜ</li>
                        <li>ÂáÜÁ°ÆÁéáËÆ°ÁÆóÈááÁî®ÁªùÂØπËØØÂ∑ÆÈòàÂÄºÔºà20ÁÆ±ÔºâÂíåÁõ∏ÂØπËØØÂ∑ÆÁªìÂêà</li>
                        <li>‰∏çÂêå‰∫ßÂìÅÁ±ªÂûãÔºàÁ®≥ÂÆö/Ê≥¢Âä®/Â≠£ËäÇÊÄßÔºâÈááÁî®‰∏çÂêåÈ¢ÑÊµãÁ≠ñÁï•</li>
                        <li>Á≥ªÁªü‰ºöËá™Âä®ÈÄâÊã©ÊúÄ‰ºòÊ®°ÂûãËøõË°åÈ¢ÑÊµã</li>
                    </ul>
                </div>
                """, unsafe_allow_html=True)
        
        # Tab 4: Â∫ìÂ≠òÁä∂ÊÄÅ
        with tabs[3]:
            st.markdown('''
            <div class="chart-header">
                <div class="chart-title">Â∫ìÂ≠òÁä∂ÊÄÅÂàÜÊûê</div>
                <div class="chart-subtitle">ÂΩìÂâçÂ∫ìÂ≠òÊÉÖÂÜµÂíåÈ£éÈô©ËØÑ‰º∞</div>
            </div>
            ''', unsafe_allow_html=True)
            
            if results['stockout_risk'] is not None and not results['stockout_risk'].empty:
                st.subheader("Áº∫Ë¥ßÈ£éÈô©‰∫ßÂìÅ")
                st.dataframe(results['stockout_risk'], use_container_width=True)
            
            if results['backlog_products'] is not None and not results['backlog_products'].empty:
                st.subheader("ÁßØÂéã‰∫ßÂìÅ")
                st.dataframe(results['backlog_products'], use_container_width=True)
            
            if show_batch and results['batch_info'] is not None and not results['batch_info'].empty:
                st.subheader("ÊâπÊ¨°‰ø°ÊÅØ")
                batch_display = results['batch_info'][results['batch_info']['ÊâπÊ¨°Âπ¥ÈæÑ(Â§©)'] > 0].head(20)
                st.dataframe(batch_display, use_container_width=True)
        
        # Tab 5: Êô∫ËÉΩÂª∫ËÆÆ
        with tabs[4]:
            st.markdown('''
            <div class="chart-header">
                <div class="chart-title">Êô∫ËÉΩÊéí‰∫ßÂª∫ËÆÆ</div>
                <div class="chart-subtitle">Âü∫‰∫éÈ¢ÑÊµãÂíåÂ∫ìÂ≠òÁöÑÁîü‰∫ßÂª∫ËÆÆ</div>
            </div>
            ''', unsafe_allow_html=True)
            
            if results['production_plan'] is not None and not results['production_plan'].empty:
                # ÊåâÊúà‰ªΩÂàÜÁªÑÊòæÁ§∫Áîü‰∫ßËÆ°Âàí
                months = results['production_plan']['Êúà‰ªΩ'].unique()
                
                for month in sorted(months)[:3]:  # Âè™ÊòæÁ§∫Ââç3‰∏™Êúà
                    st.subheader(f"üìÖ {month} Áîü‰∫ßËÆ°Âàí")
                    month_plan = results['production_plan'][results['production_plan']['Êúà‰ªΩ'] == month]
                    
                    # Âè™ÊòæÁ§∫ÈúÄË¶ÅÁîü‰∫ßÁöÑÂâç10‰∏™‰∫ßÂìÅ
                    display_plan = month_plan.nlargest(10, 'ÈúÄË¶ÅÁîü‰∫ßÊï∞Èáè')[
                        ['‰∫ßÂìÅ‰ª£Á†Å', '‰∫ßÂìÅÂêçÁß∞', 'ÂΩìÂâçÂ∫ìÂ≠ò', 'È¢ÑÊµãÈîÄÈáè', 'ÈúÄË¶ÅÁîü‰∫ßÊï∞Èáè', 'Êéí‰∫ß‰ºòÂÖàÁ∫ß']
                    ]
                    
                    st.dataframe(display_plan, use_container_width=True)
            
            # Âª∫ËÆÆËØ¥Êòé
            st.markdown("""
            <div class="insight-card">
                <h4>üéØ Êéí‰∫ßÂª∫ËÆÆËØ¥Êòé</h4>
                <ul>
                    <li><b>È´ò‰ºòÂÖàÁ∫ßÔºö</b>ÂΩìÂâçÂ∫ìÂ≠ò‰Ωé‰∫é100ÁÆ±ÁöÑ‰∫ßÂìÅ</li>
                    <li><b>Âª∫ËÆÆÁîü‰∫ßÈáèÔºö</b>Âü∫‰∫éÊúàÂùáÈîÄÈáèÁöÑ1.5ÂÄçÂáèÂéªÂΩìÂâçÂ∫ìÂ≠ò</li>
                    <li><b>ËÄÉËôëÂõ†Á¥†Ôºö</b>ÂéÜÂè≤ÈîÄÈáèË∂ãÂäø„ÄÅÂ≠£ËäÇÊÄßÂõ†Á¥†„ÄÅÂ∫ìÂ≠òÂë®ËΩ¨Áéá</li>
                    <li><b>Êõ¥Êñ∞È¢ëÁéáÔºö</b>Âª∫ËÆÆÊØèÂë®Êõ¥Êñ∞‰∏ÄÊ¨°Êéí‰∫ßËÆ°Âàí</li>
                </ul>
            </div>
            """, unsafe_allow_html=True)
    
    else:
        st.error("Êï∞ÊçÆÂä†ËΩΩÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•Êï∞ÊçÆÊ∫êÈÖçÁΩÆ")
        
except Exception as e:
    st.error(f"Á≥ªÁªüÈîôËØØ: {str(e)}")
    st.info("ËØ∑Á°Æ‰øùGitHub‰ªìÂ∫ìURLÈÖçÁΩÆÊ≠£Á°ÆÔºå‰∏îÊï∞ÊçÆÊñá‰ª∂Â≠òÂú®")

# È°µËÑö‰ø°ÊÅØ
st.markdown("---")
st.markdown(f"""
<div style="text-align: center; color: gray;">
    Êú∫Âô®Â≠¶‰π†È¢ÑÊµãÊéí‰∫ßÁ≥ªÁªü v3.0 | 
    Êï∞ÊçÆÊõ¥Êñ∞Êó∂Èó¥: {datetime.now().strftime("%Y-%m-%d %H:%M")} | 
    <a href="https://github.com/CIRA18-HUB/sales_dashboard" target="_blank">GitHub</a>
</div>
""", unsafe_allow_html=True)
